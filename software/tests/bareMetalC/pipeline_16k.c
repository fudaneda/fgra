#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include benchmark-specific header. */
#include "include/encoding.h"
#include "include/ISA.h"
#define TYPE int
#define N 64
#define SIZE 4096
#define NI 64
#define NJ 64
#define ROW 16
#define COL 16
#define HEI 16

//// ################################ ellpack ##########################################
//#define ellpackN 494
//#define ellpackL 8
//TYPE nzval[ellpackN*ellpackL] __attribute__((aligned(16)));
//TYPE cols[ellpackN*ellpackL] __attribute__((aligned(16)));
//TYPE vec[ellpackN] __attribute__((aligned(16)));
//TYPE out[ellpackN] __attribute__((aligned(16)));
////TYPE res[ellpackN] __attribute__((aligned(16)));
//
//void ellpack()
//{
//    int i, j;
//    TYPE Si;
//
//    ellpack_1 : for (i=0; i<ellpackN; i++) {
//        TYPE sum = 0;
//        ellpack_2 : for (j=0; j<ellpackL; j++) {
////        please_map_me();
//                Si = nzval[j + i*ellpackL] * vec[cols[j + i*ellpackL]];
//                sum += Si;
//        }
//        out[i] += sum;
//    }
//}
//
//void ellpack_cgra_execute(void** din_addr, void** dout_addr)
//{
//	static unsigned short cin[27][5] __attribute__((aligned(16))) = {
//		{0x0000, 0x8000, 0x0200, 0xf700, 0x0008},
//		{0x0000, 0x8000, 0x004c, 0x0000, 0x0009},
//		{0x4000, 0x8000, 0x0200, 0xf700, 0x000c},
//		{0x0000, 0x8000, 0x0000, 0x0000, 0x000d},
//		{0x0030, 0x0000, 0x0000, 0x0000, 0x001a},
//		{0x0000, 0x0010, 0x0000, 0x0000, 0x001e},
//		{0x0000, 0x0020, 0x0000, 0x0000, 0x003e},
//		{0x0000, 0x0600, 0x0000, 0x0000, 0x0042},
//		{0x0000, 0x0000, 0x3011, 0x0000, 0x0054},
//		{0x0000, 0x0004, 0x0104, 0x07b8, 0x0055},
//		{0xc000, 0x0008, 0x0000, 0x0000, 0x0062},
//		{0x0000, 0x0003, 0x0000, 0x0000, 0x0064},
//		{0x8010, 0x0000, 0x0000, 0x0000, 0x0066},
//		{0x0000, 0x0000, 0x3101, 0x0001, 0x0072},
//		{0x0000, 0x0000, 0x3603, 0x0001, 0x0076},
//		{0x0030, 0x0000, 0x0000, 0x0000, 0x0084},
//		{0x0030, 0x0000, 0x0000, 0x0000, 0x0088},
//		{0x0004, 0x0000, 0x3003, 0x0000, 0x0098},
//		{0x0000, 0x0004, 0x0000, 0x0000, 0x00a8},
//		{0x0110, 0x0000, 0x0000, 0x0000, 0x00aa},
//		{0x0000, 0x0004, 0x0000, 0x0000, 0x00ac},
//		{0x1000, 0x8000, 0x0200, 0xf700, 0x00b8},
//		{0x0000, 0x8000, 0x0003, 0x0000, 0x00b9},
//		{0x4000, 0x8000, 0x0200, 0xf700, 0x00ba},
//		{0x0000, 0x8000, 0x0000, 0x0000, 0x00bb},
//		{0x2000, 0x0000, 0x00f7, 0x0000, 0x00bc},
//		{0x0000, 0x8000, 0x0084, 0x0000, 0x00bd},
//	};
//
//	load_cfg((void*)cin, 0x40000, 270, 0, 0);
//	load_data(din_addr[0], 0x20000, 15808, 0, 0, 0);
//	load_data(din_addr[1], 0x10000, 15808, 0, 0, 0);
//	load_data(din_addr[2], 0x24000, 1976, 0, 0, 0);
//	load_data(din_addr[3], 0x28000, 1976, 0, 0, 0);
//	config(0x0, 27, 0, 0);
//	execute(0xe28, 0, 0);
//	store(dout_addr[0], 0x0, 1976, 0, 0);
//}


// ################################ gesummv ##########################################

TYPE gesummv_A[N][N] __attribute__((aligned(16)));
TYPE gesummv_B[N][N] __attribute__((aligned(16)));
TYPE gesummv_x[N] __attribute__((aligned(16)));
TYPE gesummv_y[N] __attribute__((aligned(16)));
//TYPE yy[N] __attribute__((aligned(16)));

void gesummv()
{
  int i, j;
  TYPE alpha = 3;
  TYPE beta = 2;

  for (i = 0; i < N; i++)
  {
    TYPE sum0 = 0;
    TYPE sum1 = 0;
    for (j = 0; j < N; j++)
    {
//      please_map_me();
      sum0 += gesummv_A[i][j] * gesummv_x[j];
      sum1 += gesummv_B[i][j] * gesummv_x[j];
    }
    gesummv_y[i] = alpha * sum0 + beta * sum1;
  }

}


// ################################ stencil3d ##########################################

#define INDX(_ROW,_COL,_i,_j,_k) ((_i)+_ROW*((_j)+_COL*(_k)))

TYPE stencil3d_C[2] __attribute__((aligned(16)));
TYPE stencil3d_orig[SIZE] __attribute__((aligned(16)));
TYPE stencil3d_sol[SIZE] __attribute__((aligned(16)));
//TYPE res[SIZE];

void stencil3d (){
    int i,j,k;
	int sum0, sum1, mul0, mul1;

	for(i = 1; i < HEI - 1; i++){
        for(j = 1; j < COL - 1; j++){
            for(k = 1; k < ROW - 1; k++){

                sum0 = stencil3d_orig[INDX(ROW, COL, k, j, i)];
                sum1 = stencil3d_orig[INDX(ROW, COL, k, j, i + 1)] +
                       stencil3d_orig[INDX(ROW, COL, k, j, i - 1)] +
                       stencil3d_orig[INDX(ROW, COL, k, j + 1, i)] +
                       stencil3d_orig[INDX(ROW, COL, k, j - 1, i)] +
                       stencil3d_orig[INDX(ROW, COL, k + 1, j, i)] +
                       stencil3d_orig[INDX(ROW, COL, k - 1, j, i)];
                mul0 = sum0 * stencil3d_C[0];
                mul1 = sum1 * stencil3d_C[1];
                stencil3d_sol[INDX(ROW, COL, k, j, i)] = mul0 + mul1;
            }
        }
    }
}


// ################################ mvt ##########################################
int mvt_A[N][N] __attribute__((aligned(16)));
int mvt_x1[N] __attribute__((aligned(16)));
int mvt_x2[N] __attribute__((aligned(16)));
int mvt_y_1[N] __attribute__((aligned(16)));
int mvt_y_2[N] __attribute__((aligned(16)));


void kernel_mvt()
{
  int i, j ,s1, s2;

  for (i = 0; i < N; i++)
  {
    s1 = 0;
    s2 = 0;
    for (j = 0; j < N; j++)
    {
        s1 += mvt_A[i][j] * mvt_y_1[j];
        s2 += mvt_A[j][i] * mvt_y_2[j];
    }
    mvt_x1[i] += s1;
    mvt_x2[i] += s2;
  }
}


// ################################ conv2d_3x3 ##########################################

int conv2d_3x3_A[SIZE] __attribute__((aligned(16)));
int conv2d_3x3_B[SIZE] __attribute__((aligned(16)));
int conv2d_3x3_C[SIZE] __attribute__((aligned(16)));

/*For 3x3 filter*/
#define c11 2
#define c12 -3
#define c21 5
#define c22 6
#define c13 4
#define c23 7
#define c31 -8
#define c32 -9
#define c33 10


void conv2d_3x3() {
	for (int i = 1; i < NI -1; i++) {
		for (int j = 1; j < NJ-1; j++) {
            #ifdef CGRA_COMPILER
            please_map_me();
            #endif
	        /*For 3x3 filter*/
		    conv2d_3x3_C[i*NJ + j] = c11 * conv2d_3x3_A[(i - 1)*NJ + (j - 1)]  +  c12 * conv2d_3x3_A[(i + 0)*NJ + (j - 1)]  +  c13 * conv2d_3x3_A[(i + 1)*NJ + (j - 1)]
				+ c21 * conv2d_3x3_A[(i - 1)*NJ + (j + 0)]  +  c22 * conv2d_3x3_A[(i + 0)*NJ + (j + 0)]  +  c23 * conv2d_3x3_A[(i + 1)*NJ + (j + 0)]
				+ c31 * conv2d_3x3_A[(i - 1)*NJ + (j + 1)]  +  c32 * conv2d_3x3_A[(i + 0)*NJ + (j + 1)]  +  c33 * conv2d_3x3_A[(i + 1)*NJ + (j + 1)];
		}
	}
}



// ################################ fir ##########################################
#define NTAPS 8

int fir_input[SIZE] __attribute__((aligned(16)));
int fir_output[SIZE] __attribute__((aligned(16)));
int fir_coefficients[NTAPS] __attribute__((aligned(16))) = {
025, 150, 375, -225, 050, 075, -300, 125};


void fir()//(int input[], int output[], int coefficients[])
/*   input :           input sample array */
/*   output:           output sample array */
/*   coefficient:      coefficient array */
{
   int i, j;

   for(j=0; j< SIZE; ++j) {
 	  int sum = 0;
    //#pragma unroll 4
    for (i = 0; i < NTAPS; ++i) {
      #ifdef CGRA_COMPILER
      please_map_me();
      #endif
      if(i<=j){
        sum += fir_input[j-i] * fir_coefficients[i];
      }
    }
    fir_output[j] = sum;
 }
}


// ################################ pedometer ##########################################

int acc_vector[SIZE] __attribute__((aligned(16)));
//int res_vector[SIZE] __attribute__((aligned(16)));
int acceleration_x[SIZE] __attribute__((aligned(16)));
int acceleration_y[SIZE] __attribute__((aligned(16)));
int acceleration_z[SIZE] __attribute__((aligned(16)));
int acc_avg_x[SIZE] __attribute__((aligned(16)));
int acc_avg_y[SIZE] __attribute__((aligned(16)));
int acc_avg_z[SIZE] __attribute__((aligned(16)));

/* Main computational kernel. The whole function will be timed,
   including the call and return. */

void pedometer(){
	for(int i=0;i<SIZE;i++){
	    int sub_x = acceleration_x[i]- acc_avg_x[i];
        int sub_y = acceleration_y[i]- acc_avg_y[i];
        int sub_z = acceleration_z[i]-acc_avg_z[i];
        acc_vector[i] = sub_x * sub_x+  sub_y * sub_y+ sub_z * sub_z;
//		acc_vector[i] = (acceleration_x[i]- acc_avg_x[i]) * (acceleration_x[i]- acc_avg_x[i])+  (acceleration_y[i]- acc_avg_y[i]) * (acceleration_y[i]- acc_avg_y[i])+ (acceleration_z[i]-acc_avg_z[i]) * (acceleration_z[i]-acc_avg_z[i]) ;
	}
}


// ################################ stencil2d ##########################################
#define f_size 9

TYPE stencil2d_orig[NI * NJ] __attribute__((aligned(16)));
TYPE stencil2d_sol[NI * NJ] __attribute__((aligned(16)));
TYPE stencil2d_filter[f_size] __attribute__((aligned(16)));
//TYPE stencil2d_res[NI * NJ] __attribute__((aligned(16)));


void stencil2d(){
    int r, c, k1, k2;
    TYPE temp, mul;

    for (r=0; r<NI-2; r++) {
        for (c=0; c<NJ-2; c++) {
            temp = (TYPE)0;
            for (k1=0;k1<3;k1++){
                #pragma unroll
                for (k2=0;k2<3;k2++){
                    mul = stencil2d_filter[k1*3 + k2] * stencil2d_orig[(r+k1)*NJ + c+k2];
                    temp += mul;
                }
            }
            stencil2d_sol[(r*NJ) + c] = temp;
        }
    }
}


// ################################ fft ##########################################

#define FFT_N 4096

TYPE XR0[FFT_N] __attribute__((aligned(16)));
TYPE XR1[FFT_N] __attribute__((aligned(16)));
TYPE XR2[FFT_N] __attribute__((aligned(16)));
TYPE XR3[FFT_N] __attribute__((aligned(16)));
TYPE XI0[FFT_N] __attribute__((aligned(16)));
TYPE XI1[FFT_N] __attribute__((aligned(16)));
TYPE XI2[FFT_N] __attribute__((aligned(16)));
TYPE XI3[FFT_N] __attribute__((aligned(16)));
TYPE YR0[FFT_N] __attribute__((aligned(16)));
TYPE YR1[FFT_N] __attribute__((aligned(16)));
TYPE YR2[FFT_N] __attribute__((aligned(16)));
TYPE YR3[FFT_N] __attribute__((aligned(16)));
TYPE YI0[FFT_N] __attribute__((aligned(16)));
TYPE YI1[FFT_N] __attribute__((aligned(16)));
TYPE YI2[FFT_N] __attribute__((aligned(16)));
TYPE YI3[FFT_N] __attribute__((aligned(16)));
//TYPE ZR0[FFT_N] __attribute__((aligned(16)));
//TYPE ZR1[FFT_N] __attribute__((aligned(16)));
//TYPE ZR2[FFT_N] __attribute__((aligned(16)));
//TYPE ZR3[FFT_N] __attribute__((aligned(16)));
//TYPE ZI0[FFT_N] __attribute__((aligned(16)));
//TYPE ZI1[FFT_N] __attribute__((aligned(16)));
//TYPE ZI2[FFT_N] __attribute__((aligned(16)));
//TYPE ZI3[FFT_N] __attribute__((aligned(16)));


#define cmplx_M_x(a_x, a_y, b_x, b_y) (a_x*b_x - a_y *b_y)
#define cmplx_M_y(a_x, a_y, b_x, b_y) (a_x*b_y + a_y *b_x)
#define cmplx_MUL_x(a_x, a_y, b_x, b_y ) (a_x*b_x - a_y*b_y)
#define cmplx_MUL_y(a_x, a_y, b_x, b_y ) (a_x*b_y + a_y*b_x)
#define cmplx_mul_x(a_x, a_y, b_x, b_y) (a_x*b_x - a_y*b_y)
#define cmplx_mul_y(a_x, a_y, b_x, b_y) (a_x*b_y + a_y*b_x)
#define cmplx_add_x(a_x, b_x) (a_x + b_x)
#define cmplx_add_y(a_y, b_y) (a_y + b_y)
#define cmplx_sub_x(a_x, b_x) (a_x - b_x)
#define cmplx_sub_y(a_y, b_y) (a_y - b_y)
#define cm_fl_mul_x(a_x, b) (b*a_x)
#define cm_fl_mul_y(a_y, b) (b*a_y)

#define FF2(a0_x, a0_y, a1_x, a1_y){			\
    TYPE c0_x = a0_x;		\
    TYPE c0_y = a0_y;		\
    a0_x = cmplx_add_x(c0_x, a1_x);	\
    a0_y = cmplx_add_y(c0_y, a1_y);	\
    a1_x = cmplx_sub_x(c0_x, a1_x);	\
    a1_y = cmplx_sub_y(c0_y, a1_y);	\
}

#define FFT4(a0_x, a0_y, a1_x, a1_y, a2_x, a2_y, a3_x, a3_y){           \
    TYPE exp_1_44_x;		\
    TYPE exp_1_44_y;		\
    TYPE tmp;			\
    exp_1_44_x =  0;		\
    exp_1_44_y =  -1;		\
    FF2( a0_x, a0_y, a2_x, a2_y);   \
    FF2( a1_x, a1_y, a3_x, a3_y);   \
    tmp = a3_x;			\
    a3_x = a3_x*exp_1_44_x-a3_y*exp_1_44_y;     	\
    a3_y = tmp*exp_1_44_y - a3_y*exp_1_44_x;    	\
    FF2( a0_x, a0_y, a1_x, a1_y );                  \
    FF2( a2_x, a2_y, a3_x, a3_y );                  \
}


void fft4(){
    int i;
    for(i = 0; i < FFT_N; i++){
//    please_map_me();
        TYPE a0_x = XR0[i];
        TYPE a0_y = XI0[i];
        TYPE a1_x = XR1[i];
        TYPE a1_y = XI1[i];
        TYPE a2_x = XR2[i];
        TYPE a2_y = XI2[i];
        TYPE a3_x = XR3[i];
        TYPE a3_y = XI3[i];
        FFT4(a0_x, a0_y, a1_x, a1_y, a2_x, a2_y, a3_x, a3_y);
        YR0[i] = a0_x;
        YI0[i] = a0_y;
        YR1[i] = a1_x;
        YI1[i] = a1_y;
        YR2[i] = a2_x;
        YI2[i] = a2_y;
        YR3[i] = a3_x;
        YI3[i] = a3_y;
    }
}


// ################################ gemm-unroll4 ##########################################
#define row_size 64
#define col_size 64
//#define N row_size*col_size

TYPE gemm_m1[row_size][col_size] __attribute__((aligned(16)));
TYPE gemm_m2[col_size][row_size] __attribute__((aligned(16)));
//TYPE gemm_prod0[SIZE] __attribute__((aligned(16)));
TYPE gemm_prod[row_size][row_size] __attribute__((aligned(16)));

void gemm(){
    int i, j, k;
    int k_col, i_col;
    TYPE mult;

    outer:for(i=0;i<row_size;i++) {
        middle:for(j=0;j<row_size;j++) {
            i_col = i * col_size;
            TYPE sum = 0;
            #pragma unroll 4
            for(k=0;k<col_size;k++) {
//            please_map_me();
                k_col = k * row_size;
                mult = gemm_m1[i][k] * gemm_m2[k][j]; // m1[i_col + k] * m2[k_col + j]; //
                sum += mult;
            }
            gemm_prod[i][j]  = sum;
        }
    }
}


void fir_cgra_execute(void** din_addr, void** dout_addr)
{
	static unsigned short cin[23][5] __attribute__((aligned(16))) = {
		{0xc000, 0x8fff, 0x1000, 0x0000, 0x0006},
		{0x0008, 0x8000, 0x0000, 0x0000, 0x0007},
		{0x4000, 0x8000, 0xf200, 0x007f, 0x000a},
		{0x0008, 0x8000, 0x0000, 0x0000, 0x000b},
		{0x1000, 0x8000, 0x0200, 0x0000, 0x0010},
		{0x0008, 0x8000, 0x0046, 0x0000, 0x0011},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x001a},
		{0x0000, 0x0008, 0x0000, 0x0000, 0x001c},
		{0x0800, 0x0000, 0x0000, 0x0000, 0x001e},
		{0x0010, 0x0000, 0x0000, 0x0000, 0x0022},
		{0x0000, 0x0000, 0x9043, 0x0000, 0x0030},
		{0x0000, 0x0000, 0xb421, 0x0001, 0x0032},
		{0x0000, 0x8004, 0x0102, 0x4000, 0x0033},
		{0x0040, 0x0000, 0x0000, 0x0000, 0x0044},
		{0x0000, 0x0000, 0x4006, 0x0000, 0x0054},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0068},
		{0x1000, 0x0000, 0x0000, 0x0000, 0x006a},
		{0x0000, 0x0000, 0x200a, 0x0002, 0x007a},
		{0x0001, 0x0000, 0x0011, 0x0000, 0x007c},
		{0x0000, 0x0020, 0x0000, 0x8006, 0x007d},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x008e},
		{0x0001, 0x0000, 0x0011, 0x0000, 0x00a0},
		{0x0000, 0x0004, 0x0100, 0xc000, 0x00a1},
	};

	load_cfg((void*)cin, 0x40000, 230, 0, 0);
	load_data(din_addr[0], 0x10000, 32, 0, 0, 0);
	load_data(din_addr[1], 0x0, 16384, 0, 0, 0);
	config(0x0, 23, 0, 0);
	execute(0x94, 0, 0);
	store(dout_addr[0], 0x14000, 16384, 0, 0);
}


void stencil3d_cgra_execute(void** din_addr, void** dout_addr)
{
	static unsigned short cin[49][5] __attribute__((aligned(16))) = {
		{0x6111, 0xe000, 0x0600, 0x0700, 0x0002},
		{0x0230, 0x8038, 0x0000, 0x0000, 0x0003},
		{0x70f1, 0xe000, 0x0600, 0x0700, 0x0004},
		{0x0230, 0x8038, 0x0000, 0x0000, 0x0005},
		{0x5201, 0xe000, 0x0600, 0x0700, 0x0006},
		{0x0230, 0x8038, 0x0000, 0x0000, 0x0007},
		{0x4009, 0xe000, 0x0600, 0x0700, 0x000a},
		{0x0230, 0x8038, 0x0000, 0x0000, 0x000b},
		{0x6100, 0xe000, 0x0600, 0x0700, 0x000e},
		{0x0230, 0x8038, 0x0000, 0x0000, 0x000f},
		{0x1000, 0x0000, 0x0000, 0x0000, 0x0016},
		{0x2000, 0x0000, 0x0000, 0x0000, 0x0018},
		{0x0000, 0x0031, 0x0000, 0x0000, 0x001a},
		{0x0000, 0x0002, 0x0000, 0x0000, 0x001c},
		{0x0000, 0x0002, 0x0000, 0x0000, 0x001e},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0020},
		{0x0000, 0x0000, 0x2601, 0x0001, 0x0026},
		{0x0000, 0x0000, 0xa401, 0x0000, 0x0028},
		{0x0000, 0x0000, 0xa001, 0x0000, 0x002c},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0038},
		{0xc000, 0x0000, 0x0000, 0x0000, 0x003c},
		{0x0000, 0x0002, 0x0000, 0x0000, 0x003e},
		{0x0000, 0x0000, 0x3801, 0x0001, 0x004c},
		{0x0001, 0x0000, 0x0000, 0x0000, 0x005c},
		{0x0010, 0x0000, 0x0000, 0x0000, 0x005e},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0060},
		{0x0000, 0x0000, 0x9801, 0x0001, 0x006e},
		{0x0000, 0x0000, 0x3801, 0x0002, 0x0074},
		{0x0c00, 0x0000, 0x0000, 0x0000, 0x0084},
		{0x0010, 0x0200, 0x0000, 0x0000, 0x0086},
		{0x0004, 0x0000, 0x0000, 0x0000, 0x0088},
		{0x0000, 0x0000, 0xc103, 0x0000, 0x0096},
		{0x0000, 0x0000, 0x3483, 0x0002, 0x0098},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x00a4},
		{0x0000, 0x0010, 0x0000, 0x0000, 0x00a8},
		{0x2022, 0x0000, 0x0000, 0x0000, 0x00aa},
		{0x0004, 0x0003, 0x0000, 0x0000, 0x00ac},
		{0x0000, 0x0003, 0x0000, 0x0000, 0x00ae},
		{0x0000, 0x0001, 0x0000, 0x0000, 0x00b0},
		{0x6102, 0xe000, 0x0600, 0x0700, 0x00b6},
		{0x0230, 0x8038, 0x0001, 0x0000, 0x00b7},
		{0x0000, 0xe000, 0x0000, 0x0700, 0x00b8},
		{0x0000, 0x8038, 0x0001, 0x0000, 0x00b9},
		{0x7001, 0xe000, 0x0600, 0x0700, 0x00ba},
		{0x0230, 0x8038, 0x404c, 0x0000, 0x00bb},
		{0x5101, 0xe000, 0x0600, 0x0700, 0x00bc},
		{0x0230, 0x8038, 0x0001, 0x0000, 0x00bd},
		{0x0001, 0xe000, 0x0000, 0x0700, 0x00c2},
		{0x0000, 0x8038, 0x0002, 0x0000, 0x00c3},
	};

	load_cfg((void*)cin, 0x400f0, 490, 1, 0);
	load_data(din_addr[0], 0x20000, 8, 1, 1, 0);
	load_data(din_addr[1], 0x30000, 8, 0, 1, 0);
	load_data(din_addr[2], 0x24000, 16252, 1, 1, 0);
	load_data(din_addr[3], 0x4000, 16252, 1, 1, 0);
	load_data(din_addr[4], 0x10020, 16252, 1, 1, 0);
	load_data(din_addr[5], 0x8000, 16252, 1, 1, 0);
	load_data(din_addr[6], 0xc000, 16252, 1, 1, 0);
	load_data(din_addr[7], 0x28000, 16252, 1, 1, 0);
	load_data(din_addr[8], 0x18000, 16252, 0, 1, 0);
	config(0xf, 49, 1, 0);
	execute(0x4f57, 1, 0);
	store(dout_addr[0], 0x2c000, 14204, 1, 0);
}


void gesummv_cgra_execute(void** din_addr, void** dout_addr)
{
	static unsigned short cin[30][5] __attribute__((aligned(16))) = {
		{0x4000, 0x0000, 0x0204, 0x2000, 0x0006},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x0007},
		{0x0000, 0x0000, 0x0204, 0x2000, 0x000a},
		{0x0000, 0x8000, 0x4048, 0x0000, 0x000b},
		{0x7000, 0x0000, 0x8204, 0x207f, 0x000e},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x000f},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x001a},
		{0x2000, 0x0000, 0x0000, 0x0000, 0x001c},
		{0x0003, 0x0002, 0x0000, 0x0000, 0x001e},
		{0x0000, 0x0010, 0x0000, 0x0000, 0x0020},
		{0x0000, 0x0000, 0xa203, 0x0000, 0x002c},
		{0x0000, 0x0000, 0x4011, 0x0000, 0x0030},
		{0x0000, 0x8004, 0x0802, 0x0100, 0x0031},
		{0x0001, 0x0000, 0x3007, 0x0000, 0x0032},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x003e},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0042},
		{0x0c00, 0x0000, 0x0000, 0x0000, 0x0044},
		{0x0000, 0x0000, 0x2011, 0x0000, 0x004e},
		{0x0000, 0x8004, 0x0802, 0x0100, 0x004f},
		{0x0000, 0x0000, 0xa001, 0x0001, 0x0054},
		{0x0000, 0x0000, 0xc203, 0x0000, 0x0056},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0062},
		{0x0000, 0x0040, 0x0000, 0x0000, 0x0064},
		{0x0080, 0x0000, 0x0000, 0x0000, 0x0066},
		{0x0003, 0x0000, 0x0000, 0x0000, 0x006a},
		{0x0003, 0x0000, 0x1003, 0x0000, 0x0074},
		{0x0000, 0x0020, 0x0000, 0x0000, 0x008e},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x00b2},
		{0x5000, 0x0000, 0x0204, 0x2000, 0x00c4},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x00c5},
	};

	load_cfg((void*)cin, 0x402e0, 300, 2, 0);
	load_data(din_addr[0], 0x0, 16384, 0, 2, 0);
	load_data(din_addr[1], 0x34000, 16384, 0, 2, 0);
	load_data(din_addr[2], 0x1c000, 256, 0, 2, 0);
	config(0x2e, 30, 2, 0);
	execute(0x8054, 2, 0);
	store(dout_addr[0], 0x10000, 256, 2, 0);
}


void conv2d_3x3_cgra_execute(void** din_addr, void** dout_addr)
{
	static unsigned short cin[62][5] __attribute__((aligned(16))) = {
		{0x7042, 0xe000, 0x0603, 0x1f00, 0x0002},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x0003},
		{0x6002, 0xe000, 0x0603, 0x1f00, 0x0004},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x0005},
		{0x5001, 0xe000, 0x0603, 0x1f00, 0x0006},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x0007},
		{0x6081, 0xe000, 0x0603, 0x1f00, 0x000a},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x000b},
		{0x5080, 0xe000, 0x0603, 0x1f00, 0x000e},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x000f},
		{0x0100, 0x0000, 0x0000, 0x0000, 0x0016},
		{0x0100, 0x0004, 0x0000, 0x0000, 0x0018},
		{0x0800, 0x0000, 0x0000, 0x0000, 0x001a},
		{0x2100, 0x0000, 0x0000, 0x0000, 0x001c},
		{0x0000, 0x0003, 0x0000, 0x0000, 0x001e},
		{0x0100, 0x0000, 0x0000, 0x0000, 0x0020},
		{0xfff7, 0xffff, 0x1103, 0x0000, 0x0026},
		{0xfff8, 0xffff, 0x10c3, 0x0000, 0x0028},
		{0x0005, 0x0000, 0x1003, 0x0000, 0x002a},
		{0x0000, 0x0000, 0xa801, 0x0000, 0x002c},
		{0x0007, 0x0000, 0x1043, 0x0000, 0x002e},
		{0x0002, 0x0000, 0x1007, 0x0000, 0x0032},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x003a},
		{0x3400, 0x0000, 0x0000, 0x0000, 0x003c},
		{0x1000, 0x0000, 0x0000, 0x0000, 0x003e},
		{0xc000, 0x0000, 0x0000, 0x0000, 0x0040},
		{0x0000, 0x0003, 0x0000, 0x0000, 0x0042},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0044},
		{0x0000, 0x0000, 0xa801, 0x0000, 0x004c},
		{0x0000, 0x0000, 0xa401, 0x0000, 0x004e},
		{0x0000, 0x0000, 0x3001, 0x0001, 0x0050},
		{0x0000, 0x0000, 0xc801, 0x0000, 0x0054},
		{0x0100, 0x0000, 0x0000, 0x0000, 0x005e},
		{0x0010, 0x0000, 0x0000, 0x0000, 0x0062},
		{0x0000, 0x0080, 0x0000, 0x0000, 0x0064},
		{0x0200, 0x0000, 0x0000, 0x0000, 0x0066},
		{0x0001, 0x0000, 0x0000, 0x0000, 0x0068},
		{0x0000, 0x0000, 0x9801, 0x0001, 0x0070},
		{0x0000, 0x0000, 0xc001, 0x0001, 0x0072},
		{0x0000, 0x0000, 0x1801, 0x0002, 0x0078},
		{0x0040, 0x0200, 0x0000, 0x0000, 0x0082},
		{0x0040, 0x0000, 0x0000, 0x0000, 0x0084},
		{0x0001, 0x0000, 0x0000, 0x0000, 0x0086},
		{0x0008, 0x0000, 0x0000, 0x0000, 0x008c},
		{0x0000, 0x0001, 0x0000, 0x0000, 0x008e},
		{0x000a, 0x0000, 0x4103, 0x0000, 0x0092},
		{0x0001, 0x0000, 0x4007, 0x0000, 0x0094},
		{0xfffd, 0xffff, 0x4003, 0x0000, 0x0096},
		{0x0006, 0x0000, 0x4003, 0x0000, 0x00a0},
		{0x0301, 0x0000, 0x0000, 0x0000, 0x00a6},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x00a8},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x00aa},
		{0x6082, 0xe000, 0x0603, 0x1f00, 0x00b6},
		{0x0000, 0x8000, 0x0001, 0x0000, 0x00b7},
		{0x7001, 0xe000, 0x0603, 0x1f00, 0x00b8},
		{0x0000, 0x8000, 0x004e, 0x0000, 0x00b9},
		{0x4000, 0xe000, 0x0603, 0x1f00, 0x00ba},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x00bb},
		{0x5040, 0xe000, 0x0603, 0x1f00, 0x00bc},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x00bd},
		{0x4041, 0xe000, 0x0603, 0x1f00, 0x00c4},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x00c5},
	};

	load_cfg((void*)cin, 0x40410, 620, 3, 0);
	load_data(din_addr[0], 0x20000, 16384, 1, 3, 0);
	load_data(din_addr[1], 0x24000, 16384, 1, 3, 0);
	load_data(din_addr[2], 0x14000, 16384, 1, 3, 0);
	load_data(din_addr[3], 0x4000, 16384, 1, 3, 0);
	load_data(din_addr[4], 0x30000, 16384, 1, 3, 0);
	load_data(din_addr[5], 0x18000, 16384, 1, 3, 0);
	load_data(din_addr[6], 0x8000, 16384, 1, 3, 0);
	load_data(din_addr[7], 0xc000, 16384, 1, 3, 0);
	load_data(din_addr[8], 0x28000, 16384, 0, 3, 0);
	config(0x41, 62, 3, 0);
	execute(0x8f57, 3, 0);
	store(dout_addr[0], 0x2c000, 15868, 3, 0);
}



void mvt_cgra_execute(void** din_addr, void** dout_addr)
{
	static unsigned short cin[44][5] __attribute__((aligned(16))) = {
		{0x4000, 0x0000, 0x8204, 0x207f, 0x0008},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x0009},
		{0x3000, 0x0010, 0x8204, 0x2060, 0x000e},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x000f},
		{0x4000, 0x0000, 0x8204, 0x207f, 0x0010},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x0011},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x001c},
		{0x0200, 0x0000, 0x0000, 0x0000, 0x001e},
		{0x0000, 0x0030, 0x0000, 0x0000, 0x0020},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0022},
		{0x0000, 0x0000, 0x4011, 0x0000, 0x002c},
		{0x0000, 0x8004, 0x0802, 0x0100, 0x002d},
		{0x0000, 0x0000, 0x1003, 0x0001, 0x0030},
		{0x0000, 0x0000, 0x3011, 0x0000, 0x0032},
		{0x0000, 0x0004, 0x0802, 0x0100, 0x0033},
		{0x0000, 0x0200, 0x0000, 0x0000, 0x003e},
		{0x0002, 0x0000, 0x0000, 0x0000, 0x0040},
		{0x0000, 0x0001, 0x0000, 0x0000, 0x0042},
		{0x2000, 0x0000, 0x0000, 0x0000, 0x0044},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0046},
		{0x0000, 0x0000, 0x2003, 0x0002, 0x0054},
		{0x0c00, 0x0000, 0x0000, 0x0000, 0x0062},
		{0x000c, 0x0000, 0x0000, 0x0000, 0x0068},
		{0x0c00, 0x0000, 0x0000, 0x0000, 0x006a},
		{0x0000, 0x0000, 0xc0c1, 0x0000, 0x0074},
		{0x0000, 0x0000, 0xb041, 0x0000, 0x007c},
		{0x0000, 0x0200, 0x0000, 0x0000, 0x0086},
		{0x0003, 0x0000, 0x0000, 0x0000, 0x0088},
		{0x0000, 0x0820, 0x0000, 0x0000, 0x008c},
		{0x0030, 0x0000, 0x0000, 0x0000, 0x008e},
		{0x0300, 0x0000, 0x0000, 0x0000, 0x00aa},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x00ac},
		{0x2000, 0x0000, 0x0000, 0x0000, 0x00b0},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x00b2},
		{0x0000, 0x0000, 0x0204, 0x2000, 0x00bc},
		{0x0000, 0x8000, 0x0047, 0x0000, 0x00bd},
		{0x2000, 0x0000, 0x0204, 0x2000, 0x00be},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x00bf},
		{0x0000, 0x0000, 0x0204, 0x2000, 0x00c0},
		{0x0000, 0x8000, 0x4047, 0x0000, 0x00c1},
		{0x5000, 0x0000, 0x0204, 0x2000, 0x00c2},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x00c3},
		{0x3000, 0x0000, 0x0204, 0x2000, 0x00c4},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x00c5},
	};

	load_cfg((void*)cin, 0x40000, 440, 4, 0);
	load_data(din_addr[0], 0x34000, 16384, 1, 4, 0);
	load_data(din_addr[1], 0x1c000, 16384, 0, 4, 0);
	load_data(din_addr[2], 0x38000, 256, 0, 4, 0);
	load_data(din_addr[3], 0x3c000, 256, 0, 4, 0);
	load_data(din_addr[4], 0x0, 256, 0, 4, 0);
	load_data(din_addr[5], 0x10000, 256, 0, 4, 3);
	config(0x0, 44, 4, 0);
	execute(0xf8c8, 4, 0);
	store(dout_addr[0], 0x20000, 256, 4, 0);
	store(dout_addr[1], 0x30000, 256, 4, 0);
}


void pedometer_cgra_execute(void** din_addr, void** dout_addr)
{
	static unsigned short cin[38][5] __attribute__((aligned(16))) = {
		{0x6000, 0x0000, 0x0100, 0x0000, 0x0004},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x0005},
		{0x4000, 0x0000, 0x0100, 0x0000, 0x0006},
		{0x0000, 0x8000, 0x4048, 0x0000, 0x0007},
		{0x5000, 0x0000, 0x0100, 0x0000, 0x0008},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x0009},
		{0x6000, 0x0000, 0x0100, 0x0000, 0x000a},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x000b},
		{0x5000, 0x0000, 0x0100, 0x0000, 0x000c},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x000d},
		{0x0000, 0x0010, 0x0000, 0x0000, 0x0016},
		{0x0003, 0x0000, 0x0000, 0x0000, 0x001a},
		{0x2100, 0x0000, 0x0000, 0x0000, 0x001c},
		{0x0000, 0x0011, 0x0000, 0x0000, 0x001e},
		{0x0000, 0x0000, 0xa001, 0x0001, 0x002c},
		{0x0000, 0x0000, 0x9002, 0x0000, 0x002e},
		{0x0000, 0x0000, 0xb003, 0x0001, 0x0030},
		{0x0300, 0x0000, 0x0000, 0x0000, 0x003a},
		{0x0140, 0x0000, 0x0000, 0x0000, 0x003e},
		{0x0000, 0x0600, 0x0000, 0x0000, 0x0042},
		{0x0000, 0x0000, 0x9002, 0x0001, 0x004c},
		{0x0000, 0x0000, 0xb003, 0x0001, 0x004e},
		{0x0000, 0x0000, 0x1001, 0x0002, 0x0050},
		{0x00c0, 0x0000, 0x0000, 0x0000, 0x005e},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0060},
		{0x000c, 0x0000, 0x0000, 0x0000, 0x0064},
		{0x8000, 0x0000, 0x0000, 0x0000, 0x0066},
		{0x0000, 0x0000, 0x3002, 0x0001, 0x0076},
		{0x0000, 0x0020, 0x0000, 0x0000, 0x0082},
		{0x0000, 0x0100, 0x0000, 0x0000, 0x0086},
		{0x0520, 0x0000, 0x0000, 0x0000, 0x0088},
		{0x0000, 0x0000, 0x9003, 0x0000, 0x009a},
		{0x0000, 0x0004, 0x0000, 0x0000, 0x00a6},
		{0x0000, 0x0004, 0x0000, 0x0000, 0x00aa},
		{0x5000, 0x0000, 0x0100, 0x0000, 0x00b6},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x00b7},
		{0x6000, 0x0000, 0x0100, 0x0000, 0x00ba},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x00bb},
	};

	load_cfg((void*)cin, 0x401c0, 380, 5, 0);
	load_data(din_addr[0], 0x24000, 16384, 0, 5, 0);
	load_data(din_addr[1], 0x4000, 16384, 0, 5, 0);
	load_data(din_addr[2], 0x14000, 16384, 0, 5, 0);
	load_data(din_addr[3], 0x8000, 16384, 0, 5, 0);
	load_data(din_addr[4], 0x18000, 16384, 0, 5, 0);
	load_data(din_addr[5], 0x28000, 16384, 0, 5, 0);
	config(0x1c, 38, 5, 0);
	execute(0x53e, 5, 0);
	store(dout_addr[0], 0x0, 16384, 5, 0);
}



void stencil2d_cgra_execute(void** din_addr, void** dout_addr)
{
	static unsigned short cin[44][5] __attribute__((aligned(16))) = {
		{0x3000, 0x3010, 0x0200, 0x1f7f, 0x0002},
		{0xf830, 0x80fb, 0x0000, 0x0000, 0x0003},
		{0x1000, 0x3000, 0x0200, 0x1f00, 0x0008},
		{0x0030, 0x80f8, 0x4049, 0x0000, 0x0009},
		{0xc000, 0x3000, 0xf400, 0x1f7f, 0x000c},
		{0xffa0, 0x80fb, 0x0000, 0x0000, 0x000d},
		{0xf001, 0x3000, 0xf400, 0x1f7f, 0x0010},
		{0xffa0, 0x80fb, 0x0000, 0x0000, 0x0011},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0016},
		{0x8000, 0x0000, 0x0000, 0x0000, 0x0018},
		{0x0000, 0x0002, 0x0000, 0x0000, 0x001a},
		{0x0001, 0x0002, 0x0000, 0x0000, 0x001c},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x001e},
		{0x0000, 0x0010, 0x0000, 0x0000, 0x0022},
		{0x0000, 0x0000, 0x1083, 0x0001, 0x0028},
		{0x0000, 0x0000, 0x4011, 0x0000, 0x002c},
		{0x0000, 0x0004, 0x0064, 0x3c10, 0x002d},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x003c},
		{0x0000, 0x0040, 0x0000, 0x0000, 0x003e},
		{0x0800, 0x0000, 0x0000, 0x0000, 0x0040},
		{0x3000, 0x0000, 0x0000, 0x0000, 0x0042},
		{0x0000, 0x0004, 0x0000, 0x0000, 0x0044},
		{0x0000, 0x0600, 0x0000, 0x0000, 0x0046},
		{0x0000, 0x0000, 0x1001, 0x0002, 0x004e},
		{0x0000, 0x0000, 0xa041, 0x0000, 0x0052},
		{0x0008, 0x0000, 0x0000, 0x0000, 0x0062},
		{0x0000, 0x0003, 0x0000, 0x0000, 0x0064},
		{0x0000, 0x0003, 0x0000, 0x0000, 0x0066},
		{0x0000, 0x0004, 0x0000, 0x0000, 0x0068},
		{0x8000, 0x0000, 0x0000, 0x0000, 0x006a},
		{0x0000, 0x0000, 0x3003, 0x0001, 0x007a},
		{0x0000, 0x0100, 0x0000, 0x0000, 0x0088},
		{0x0000, 0x0080, 0x0000, 0x0000, 0x008a},
		{0x0020, 0x0000, 0x0000, 0x0000, 0x008c},
		{0x0000, 0x0000, 0x3003, 0x0002, 0x009e},
		{0x0000, 0x0004, 0x0000, 0x0000, 0x00ac},
		{0x0010, 0x0000, 0x0000, 0x0000, 0x00b0},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x00b2},
		{0x3001, 0x3010, 0x0200, 0x1f7f, 0x00bc},
		{0xf830, 0x80fb, 0x0000, 0x0000, 0x00bd},
		{0x2002, 0x3010, 0x0200, 0x1f7f, 0x00c0},
		{0xf830, 0x80fb, 0x0000, 0x0000, 0x00c1},
		{0xd002, 0x3000, 0xf400, 0x1f7f, 0x00c4},
		{0xffa0, 0x80fb, 0x0000, 0x0000, 0x00c5},
	};

	load_cfg((void*)cin, 0x40340, 440, 6, 0);
	load_data(din_addr[0], 0x10000, 36, 1, 6, 0);
	load_data(din_addr[1], 0x1c000, 36, 1, 6, 0);
	load_data(din_addr[2], 0x34000, 36, 0, 6, 0);
	load_data(din_addr[3], 0xc000, 16384, 1, 6, 0);
	load_data(din_addr[4], 0x2c000, 16384, 1, 6, 0);
	load_data(din_addr[5], 0x38000, 16384, 0, 6, 0);
	config(0x34, 44, 6, 0);
	execute(0xa8a9, 6, 0);
	store(dout_addr[0], 0x4000, 15864, 6, 0);
}



void fft_cgra_execute(void** din_addr, void** dout_addr)
{
	static unsigned short cin[80][5] __attribute__((aligned(16))) = {
		{0x5000, 0x0000, 0x0100, 0x0000, 0x0002},
		{0x0000, 0x8000, 0x4047, 0x0000, 0x0003},
		{0x7000, 0x0000, 0x0100, 0x0000, 0x0004},
		{0x0000, 0x8000, 0x4047, 0x0000, 0x0005},
		{0x6000, 0x0000, 0x0100, 0x0000, 0x0006},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x0007},
		{0x4000, 0x0000, 0x0100, 0x0000, 0x0008},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x0009},
		{0x6000, 0x0000, 0x0100, 0x0000, 0x000a},
		{0x0000, 0x8000, 0x0048, 0x0000, 0x000b},
		{0x5000, 0x0000, 0x0100, 0x0000, 0x000c},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x000d},
		{0x4000, 0x0000, 0x0100, 0x0000, 0x000e},
		{0x0000, 0x8000, 0x0047, 0x0000, 0x000f},
		{0x7000, 0x0000, 0x0100, 0x0000, 0x0010},
		{0x0000, 0x8000, 0x0048, 0x0000, 0x0011},
		{0x0003, 0x0000, 0x0000, 0x0000, 0x0016},
		{0x0000, 0x0010, 0x0000, 0x0000, 0x0018},
		{0x0000, 0x001c, 0x0000, 0x0000, 0x001a},
		{0x0020, 0x0000, 0x0000, 0x0000, 0x001c},
		{0x0000, 0x0014, 0x0000, 0x0000, 0x001e},
		{0x0020, 0x0000, 0x0000, 0x0000, 0x0020},
		{0x0030, 0x0000, 0x0000, 0x0000, 0x0022},
		{0x0000, 0x0000, 0x4001, 0x0002, 0x002a},
		{0x0000, 0x0000, 0x1041, 0x0002, 0x002c},
		{0x0000, 0x0000, 0x3002, 0x0002, 0x002e},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x003a},
		{0xdc00, 0x0000, 0x0000, 0x0000, 0x003c},
		{0x3c04, 0x0621, 0x0000, 0x0000, 0x003e},
		{0x000c, 0x0004, 0x0000, 0x0000, 0x0040},
		{0x1c00, 0x00c0, 0x0000, 0x0000, 0x0042},
		{0x0200, 0x0000, 0x0000, 0x0000, 0x0044},
		{0x0000, 0x0020, 0x0000, 0x0000, 0x0046},
		{0x0000, 0x0000, 0x2002, 0x0001, 0x004c},
		{0x0000, 0x0000, 0xa402, 0x0000, 0x004e},
		{0x0000, 0x0000, 0xb202, 0x0000, 0x0050},
		{0x0000, 0x0000, 0xa001, 0x0000, 0x0052},
		{0x0000, 0x0000, 0xc001, 0x0000, 0x0054},
		{0x0000, 0x0000, 0x9002, 0x0001, 0x0056},
		{0x0000, 0x0100, 0x0000, 0x0000, 0x0060},
		{0x1c20, 0x0020, 0x0000, 0x0000, 0x0062},
		{0x0000, 0x0020, 0x0000, 0x0000, 0x0064},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0066},
		{0x04c3, 0x0000, 0x0000, 0x0000, 0x0068},
		{0x0000, 0x0008, 0x0000, 0x0000, 0x006a},
		{0x0000, 0x0000, 0x2001, 0x0002, 0x0072},
		{0x0000, 0x0000, 0xb001, 0x0000, 0x0074},
		{0x0000, 0x0000, 0xa041, 0x0001, 0x0078},
		{0x0000, 0x0000, 0xb202, 0x0000, 0x007a},
		{0x0000, 0x0218, 0x0000, 0x0000, 0x0084},
		{0x0434, 0x0004, 0x0000, 0x0000, 0x0086},
		{0x0000, 0x0020, 0x0000, 0x0000, 0x0088},
		{0x0040, 0x0640, 0x0000, 0x0000, 0x008a},
		{0x0020, 0x0020, 0x0000, 0x0000, 0x008c},
		{0x0000, 0x0000, 0xc041, 0x0001, 0x0096},
		{0x0000, 0x0000, 0xb002, 0x0000, 0x0098},
		{0x0000, 0x0000, 0xb402, 0x0001, 0x009a},
		{0x0000, 0x0010, 0x0000, 0x0000, 0x00a6},
		{0x2080, 0x0020, 0x0000, 0x0000, 0x00a8},
		{0x0000, 0x0024, 0x0000, 0x0000, 0x00aa},
		{0x0060, 0x0000, 0x0000, 0x0000, 0x00ac},
		{0x0300, 0x0000, 0x0000, 0x0000, 0x00ae},
		{0x0000, 0x0030, 0x0000, 0x0000, 0x00b0},
		{0x0200, 0x0000, 0x0000, 0x0000, 0x00b2},
		{0x4000, 0x0000, 0x0100, 0x0000, 0x00b6},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x00b7},
		{0x7000, 0x0000, 0x0100, 0x0000, 0x00b8},
		{0x0000, 0x8000, 0x4047, 0x0000, 0x00b9},
		{0x6000, 0x0000, 0x0100, 0x0000, 0x00ba},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x00bb},
		{0x5000, 0x0000, 0x0100, 0x0000, 0x00bc},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x00bd},
		{0x4000, 0x0000, 0x0100, 0x0000, 0x00be},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x00bf},
		{0x5000, 0x0000, 0x0100, 0x0000, 0x00c0},
		{0x0000, 0x8000, 0x0047, 0x0000, 0x00c1},
		{0x7000, 0x0000, 0x0100, 0x0000, 0x00c2},
		{0x0000, 0x8000, 0x0000, 0x0000, 0x00c3},
		{0x6000, 0x0000, 0x0100, 0x0000, 0x00c4},
		{0x0000, 0x8000, 0x0048, 0x0000, 0x00c5},
	};

	load_cfg((void*)cin, 0x40000, 800, 7, 0);
	load_data(din_addr[0], 0x30000, 16384, 0, 7, 0);
	load_data(din_addr[1], 0x14000, 16384, 0, 7, 0);
	load_data(din_addr[2], 0x8000, 16384, 0, 7, 0);
	load_data(din_addr[3], 0x3c000, 16384, 0, 7, 0);
	load_data(din_addr[4], 0x20000, 16384, 0, 7, 0);
	load_data(din_addr[5], 0x24000, 16384, 0, 7, 0);
	load_data(din_addr[6], 0x28000, 16384, 0, 7, 0);
	load_data(din_addr[7], 0x0, 16384, 0, 7, 3);
	config(0x0, 80, 7, 0);
	execute(0xffff, 7, 1);
	store(dout_addr[0], 0x2c000, 16384, 7, 0);
	store(dout_addr[1], 0x34000, 16384, 7, 0);
	store(dout_addr[2], 0x18000, 16384, 7, 0);
	store(dout_addr[3], 0x10000, 16384, 7, 0);
	store(dout_addr[4], 0x38000, 16384, 7, 0);
	store(dout_addr[5], 0xc000, 16384, 7, 0);
	store(dout_addr[6], 0x1c000, 16384, 7, 0);
	store(dout_addr[7], 0x4000, 16384, 7, 0);
}


void gemm_cgra_execute(void** din_addr, void** dout_addr)
{
	static unsigned short cin[44][5] __attribute__((aligned(16))) = {
		{0x2003, 0x0001, 0x8801, 0x207f, 0x0002},
		{0x0040, 0x8100, 0x0000, 0x0000, 0x0003},
		{0x0001, 0x0001, 0x8801, 0x207f, 0x0006},
		{0x0040, 0x8100, 0x0000, 0x0000, 0x0007},
		{0x1000, 0x0000, 0x0201, 0x2000, 0x0008},
		{0x0010, 0x8100, 0x0049, 0x0000, 0x0009},
		{0x1040, 0x0040, 0x0201, 0x2062, 0x000a},
		{0x0c10, 0x8103, 0x0000, 0x0000, 0x000b},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0016},
		{0x0400, 0x0000, 0x0000, 0x0000, 0x0018},
		{0x2030, 0x0000, 0x0000, 0x0000, 0x001a},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x001c},
		{0x0000, 0x0000, 0xa003, 0x0000, 0x002a},
		{0x0000, 0x0600, 0x0000, 0x0000, 0x003a},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x003c},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x003e},
		{0x0000, 0x0000, 0x2081, 0x0002, 0x004c},
		{0x0000, 0x0000, 0x4011, 0x0000, 0x0050},
		{0x0000, 0x0004, 0x0204, 0x4000, 0x0051},
		{0x0c00, 0x0000, 0x0000, 0x0000, 0x005e},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0060},
		{0x0800, 0x0000, 0x0000, 0x0000, 0x0062},
		{0x0001, 0x0000, 0x0000, 0x0000, 0x0064},
		{0x0000, 0x0000, 0xc043, 0x0000, 0x0070},
		{0x0000, 0x0000, 0xb001, 0x0001, 0x0072},
		{0x0000, 0x0000, 0xc0c1, 0x0000, 0x0074},
		{0x0013, 0x0000, 0x0000, 0x0000, 0x0084},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0088},
		{0x0000, 0x0000, 0xc203, 0x0001, 0x0094},
		{0x0000, 0x0000, 0x4003, 0x0002, 0x009a},
		{0x0040, 0x0000, 0x0000, 0x0000, 0x00a6},
		{0x0002, 0x0000, 0x0000, 0x0000, 0x00a8},
		{0x0000, 0x0001, 0x0000, 0x0000, 0x00aa},
		{0x0004, 0x0000, 0x0000, 0x0000, 0x00ae},
		{0x0000, 0x0001, 0x8801, 0x207f, 0x00b6},
		{0x0040, 0x8100, 0x0000, 0x0000, 0x00b7},
		{0x20c0, 0x0040, 0x0201, 0x2062, 0x00ba},
		{0x0c10, 0x8103, 0x0000, 0x0000, 0x00bb},
		{0x1000, 0x0040, 0x0201, 0x2062, 0x00bc},
		{0x0c10, 0x8103, 0x0000, 0x0000, 0x00bd},
		{0x0002, 0x0001, 0x8801, 0x207f, 0x00be},
		{0x0040, 0x8100, 0x0000, 0x0000, 0x00bf},
		{0x3080, 0x0040, 0x0201, 0x2062, 0x00c0},
		{0x0c10, 0x8103, 0x0000, 0x0000, 0x00c1},
	};

	load_cfg((void*)cin, 0x40320, 440, 8, 0);
	load_data(din_addr[0], 0x20000, 16384, 1, 8, 2);
	load_data(din_addr[1], 0x0, 16384, 1, 8, 2);
	load_data(din_addr[2], 0x30000, 16384, 1, 8, 2);
	load_data(din_addr[3], 0x8000, 16384, 0, 8, 2);
	load_data(din_addr[4], 0x24000, 16384, 1, 8, 2);
	load_data(din_addr[5], 0x14000, 16384, 1, 8, 2);
	load_data(din_addr[6], 0x3c000, 16384, 1, 8, 2);
	load_data(din_addr[7], 0x28000, 16384, 0, 8, 2);
	config(0x32, 44, 8, 0);
	execute(0x3d1d, 8, 1);
	store(dout_addr[0], 0x4000, 16384, 8, 0);
}



///* Array initialization. */
//void init_array()
//{
//int i,j;
//for (i=0;i<array_add_SIZE; i++){
//      gemver_A[i] = i * 2 + 5;
//      conv2d_2x2_B[i] = i * 3;
//    }
//
//}
//
//void result_check()
//{
//  int i, j;
//
//  for (i = 0; i < array_add_SIZE; i++)
//  {
//    if (conv2d_2x2_C[i] != D[i]) printf("There is an error in location (%d)[%d, %d]\n", i, conv2d_2x2_C[i], D[i]);
//  }
//}


int main(int argc, char** argv)
{
  long long unsigned start;
  long long unsigned end;
  volatile int result;
//  init_array();
  printf("Initialization finished!\n");

//  start = rdcycle();
//  /* Run kernels. */
////  ellpack();
//  fir();
//  stencil3d();
//  gesummv();
//  conv2d_3x3();
//  kernel_mvt();
//  pedometer();
//  stencil2d();
//  fft4();
//  gemm();
//  end = rdcycle();
//  printf("It takes %d cycles for CPU to finish the task.\n", end - start);

  start = rdcycle();

//  void* ellpack_cgra_din_addr[4] = {cols, nzval, out, vec};
//  void* ellpack_cgra_dout_addr[1] = {out};
//  ellpack_cgra_execute(ellpack_cgra_din_addr, ellpack_cgra_dout_addr);
//  result = fence(1);

  void* fir_cgra_din_addr[2] = {fir_coefficients, fir_input};
  void* fir_cgra_dout_addr[1] = {fir_output};
  fir_cgra_execute(fir_cgra_din_addr, fir_cgra_dout_addr);
//  result = fence(1);

  void* stencil3d_cgra_din_addr[9] = {stencil3d_C, stencil3d_C, (void*)stencil3d_orig+64, (void*)stencil3d_orig+64,
        (void*)stencil3d_orig+64, (void*)stencil3d_orig+64, (void*)stencil3d_orig+64, (void*)stencil3d_orig+64, (void*)stencil3d_orig+64};
  void* stencil3d_cgra_dout_addr[1] = {(void*)stencil3d_sol+1088};
  stencil3d_cgra_execute(stencil3d_cgra_din_addr, stencil3d_cgra_dout_addr);
//  result = fence(1);

  void* gesummv_cgra_din_addr[3] = {gesummv_A, gesummv_B, gesummv_x};
  void* gesummv_cgra_dout_addr[1] = {gesummv_y};
  gesummv_cgra_execute(gesummv_cgra_din_addr, gesummv_cgra_dout_addr);
//  result = fence(1);

  void* conv2d_3x3_cgra_din_addr[9] = {conv2d_3x3_A, conv2d_3x3_A, conv2d_3x3_A, conv2d_3x3_A, conv2d_3x3_A, conv2d_3x3_A, conv2d_3x3_A, conv2d_3x3_A, conv2d_3x3_A};
  void* conv2d_3x3_cgra_dout_addr[1] = {(void*)conv2d_3x3_B+256};
  conv2d_3x3_cgra_execute(conv2d_3x3_cgra_din_addr, conv2d_3x3_cgra_dout_addr);
//  result = fence(1);

  void* mvt_cgra_din_addr[6] = {mvt_A, mvt_A, mvt_x2, mvt_y_1, mvt_y_2, mvt_x1};
  void* mvt_cgra_dout_addr[2] = {mvt_x1, mvt_x2};
  mvt_cgra_execute(mvt_cgra_din_addr, mvt_cgra_dout_addr);
//  result = fence(1);

  void* pedometer_cgra_din_addr[6] = {acc_avg_x, acc_avg_y, acc_avg_z, acceleration_x, acceleration_y, acceleration_z};
  void* pedometer_cgra_dout_addr[1] = {acc_vector};
  pedometer_cgra_execute(pedometer_cgra_din_addr, pedometer_cgra_dout_addr);
//  result = fence(1);

  void* stencil2d_cgra_din_addr[6] = {stencil2d_filter, stencil2d_filter, stencil2d_filter, stencil2d_orig, stencil2d_orig, stencil2d_orig};
  void* stencil2d_cgra_dout_addr[1] = {stencil2d_sol};
  stencil2d_cgra_execute(stencil2d_cgra_din_addr, stencil2d_cgra_dout_addr);
//  result = fence(1);

  void* fft_cgra_din_addr[8] = {XI0, XI1, XI3, XR0, XR1, XR2, XR3, XI2};
  void* fft_cgra_dout_addr[8] = {YR0, YI0, YR1, YI1, YR2, YI2, YR3, YI3};
  fft_cgra_execute(fft_cgra_din_addr, fft_cgra_dout_addr);
//  result = fence(1);

  void* gemm_cgra_din_addr[8] = {gemm_m1, gemm_m1, gemm_m1, gemm_m1, gemm_m2, gemm_m2, gemm_m2, gemm_m2};
  void* gemm_cgra_dout_addr[1] = {gemm_prod};
  gemm_cgra_execute(gemm_cgra_din_addr, gemm_cgra_dout_addr);
  result = fence(1);

  end = rdcycle();
  printf("It takes %d cycles for CGRA to finish the task(%d).\n", end - start, result);

//  result_check();
  printf("Done!\n");

  return 0;
}