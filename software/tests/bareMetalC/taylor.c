#include <string.h>
#include <stdio.h>
#include "include/encoding.h"
#include "include/ISA.h"

__attribute__((noinline))
void cgra_execute(void** din_addr, void** dout_addr)
{
	static unsigned short cin[161][3] __attribute__((aligned(16))) = {
		{0x2800, 0x8000, 0x0010},
		{0x0080, 0x0200, 0x0011},
		{0x0000, 0xb000, 0x0012},
		{0x0005, 0x0000, 0x0013},
		{0x0000, 0x0000, 0x0014},
		{0x2000, 0x8000, 0x0020},
		{0x0080, 0x0200, 0x0021},
		{0x0000, 0xb000, 0x0022},
		{0x0005, 0x0000, 0x0023},
		{0x0000, 0x0000, 0x0024},
		{0x2400, 0x8000, 0x0030},
		{0x0080, 0x0200, 0x0031},
		{0x0000, 0x3000, 0x0032},
		{0x0006, 0x0000, 0x0033},
		{0x0000, 0x0000, 0x0034},
		{0x0030, 0x0000, 0x0058},
		{0x0030, 0x0000, 0x0068},
		{0x0030, 0x0000, 0x0078},
		{0x0200, 0x0000, 0x0080},
		{0x0000, 0x0018, 0x00b8},
		{0x2000, 0x0004, 0x00c0},
		{0x001f, 0x0000, 0x0108},
		{0x800a, 0x0081, 0x010a},
		{0x0000, 0x4000, 0x010b},
		{0x000d, 0x0000, 0x010c},
		{0x0001, 0x0000, 0x0110},
		{0x0011, 0x0100, 0x0112},
		{0x0000, 0x8000, 0x0113},
		{0x000a, 0x0000, 0x0114},
		{0x6000, 0x0000, 0x0115},
		{0x0808, 0x0300, 0x0116},
		{0x001f, 0x0000, 0x0118},
		{0x000e, 0x0002, 0x011a},
		{0x0008, 0x0000, 0x0128},
		{0x0080, 0x0008, 0x0130},
		{0x0000, 0x0240, 0x0138},
		{0xc080, 0x0040, 0x0140},
		{0xc080, 0x0000, 0x0148},
		{0xc000, 0x0002, 0x0150},
		{0x0000, 0x0001, 0x0158},
		{0x0000, 0x0000, 0x0160},
		{0x0060, 0x0000, 0x0170},
		{0x0080, 0x0000, 0x0179},
		{0x2000, 0x0000, 0x0181},
		{0x0000, 0x0002, 0x0189},
		{0x0000, 0x0100, 0x0190},
		{0x8a20, 0x0001, 0x0199},
		{0x0020, 0x0000, 0x01a0},
		{0x8140, 0x0001, 0x01a1},
		{0x0100, 0x0000, 0x01a8},
		{0x0000, 0x0000, 0x01a9},
		{0x001f, 0x0000, 0x01c0},
		{0x000e, 0x0001, 0x01c2},
		{0x008c, 0x0015, 0x01d2},
		{0x0060, 0x2800, 0x01d3},
		{0x100c, 0x06b5, 0x01da},
		{0x00e0, 0xb000, 0x01db},
		{0x0036, 0x0000, 0x01dc},
		{0x0000, 0x0000, 0x01e0},
		{0x808a, 0x0001, 0x01e2},
		{0x000a, 0x0000, 0x0200},
		{0x4000, 0x0108, 0x0208},
		{0x0000, 0x01c6, 0x0210},
		{0x4080, 0x0006, 0x0218},
		{0x4004, 0x0000, 0x0220},
		{0x4004, 0x0040, 0x0228},
		{0x6200, 0x0008, 0x0230},
		{0x0000, 0x0001, 0x0238},
		{0x0000, 0x0000, 0x0248},
		{0x0000, 0x0080, 0x0250},
		{0x6000, 0x0000, 0x0251},
		{0x0000, 0x0080, 0x0258},
		{0x3000, 0x0000, 0x0259},
		{0x4000, 0x0003, 0x0261},
		{0x0010, 0x0000, 0x0268},
		{0x4040, 0x0000, 0x0269},
		{0x0000, 0x0000, 0x0270},
		{0x8000, 0x0002, 0x0271},
		{0x0000, 0x0040, 0x0278},
		{0x0000, 0x0000, 0x0279},
		{0x0800, 0x0000, 0x0281},
		{0x0001, 0x0000, 0x0298},
		{0x0011, 0x0100, 0x029a},
		{0x2000, 0x8000, 0x029b},
		{0x0006, 0x0000, 0x029c},
		{0x0300, 0x0000, 0x029d},
		{0x0008, 0x0301, 0x029e},
		{0x0000, 0x0000, 0x02a0},
		{0x010a, 0x06a2, 0x02a2},
		{0x2200, 0x8000, 0x02a3},
		{0x003c, 0x0000, 0x02a4},
		{0x0001, 0x0000, 0x02a8},
		{0x0007, 0x0001, 0x02aa},
		{0x0001, 0x0000, 0x02b0},
		{0x0007, 0x0002, 0x02b2},
		{0x018c, 0x000e, 0x02ba},
		{0x0020, 0x1000, 0x02bb},
		{0x800c, 0x000a, 0x02c2},
		{0x0040, 0x1000, 0x02c3},
		{0x0004, 0x0000, 0x02d8},
		{0x3000, 0x0002, 0x02e0},
		{0x8000, 0x0046, 0x02e8},
		{0x4080, 0x0010, 0x02f0},
		{0x2020, 0x0000, 0x02f8},
		{0x0010, 0x0201, 0x0300},
		{0xc000, 0x0248, 0x0308},
		{0x1a00, 0x0003, 0x0310},
		{0x0002, 0x0000, 0x0318},
		{0x0000, 0x0000, 0x0329},
		{0x9000, 0x0002, 0x0339},
		{0x0800, 0x0000, 0x0341},
		{0x8000, 0x0002, 0x0349},
		{0x8202, 0x000d, 0x036a},
		{0x001f, 0x0000, 0x0370},
		{0x080a, 0x0008, 0x0372},
		{0x8802, 0x0016, 0x037a},
		{0x0002, 0x000d, 0x0382},
		{0x0102, 0x0016, 0x038a},
		{0x8102, 0x0016, 0x0392},
		{0x9002, 0x0011, 0x039a},
		{0x1002, 0x000a, 0x03a2},
		{0x0000, 0x0000, 0x03b0},
		{0x6000, 0x0000, 0x03c0},
		{0x0801, 0x0000, 0x03c8},
		{0x1804, 0x0000, 0x03d0},
		{0xb002, 0x0000, 0x03d8},
		{0x8800, 0x0001, 0x03e0},
		{0x8008, 0x0000, 0x03e8},
		{0x0001, 0x0000, 0x03f0},
		{0x0400, 0x0000, 0x0410},
		{0x0060, 0x0000, 0x0420},
		{0x2000, 0x8000, 0x0440},
		{0x0080, 0x0200, 0x0441},
		{0x0000, 0xb000, 0x0442},
		{0x0000, 0x0008, 0x0443},
		{0x3fe0, 0x8000, 0x0450},
		{0x0080, 0x0200, 0x0451},
		{0x0000, 0xb000, 0x0452},
		{0x1202, 0x0018, 0x0453},
		{0x0400, 0x0000, 0x0454},
		{0x2001, 0x8000, 0x0458},
		{0x0080, 0x0200, 0x0459},
		{0x0000, 0x3000, 0x045a},
		{0x1200, 0x0008, 0x045b},
		{0x3fff, 0x8000, 0x0460},
		{0x0080, 0x0200, 0x0461},
		{0x0000, 0xb000, 0x0462},
		{0x1200, 0x0008, 0x0463},
		{0x3fe0, 0x8000, 0x0468},
		{0x0080, 0x0200, 0x0469},
		{0x0000, 0x3000, 0x046a},
		{0x1202, 0x0018, 0x046b},
		{0x0000, 0x0000, 0x046c},
		{0x2000, 0x8000, 0x0470},
		{0x0080, 0x0200, 0x0471},
		{0x0000, 0x3000, 0x0472},
		{0x1201, 0x0008, 0x0473},
		{0x2020, 0x8000, 0x0478},
		{0x0080, 0x0200, 0x0479},
		{0x0000, 0xb000, 0x047a},
		{0x1201, 0x0008, 0x047b},
	};

	load_cfg((void*)cin, 0x10000, 966, 0, 0);
	load_data(din_addr[0], 0x9000, 4224, 1, 0, 0, 1, 0);
	load_data(din_addr[0], 0xa000, 4224, 0, 0, 0, 1, 0);
	load_data(din_addr[1], 0x8000, 4096, 0, 0, 0, 0, 0);
	config(0x0, 161, 0, 0);
	execute(0xfd2a, 0, 0);
	store(dout_addr[0], 0x0, 4096, 0, 0, 0, 0, 0);
	store(dout_addr[1], 0x1000, 4096, 0, 0, 0, 0, 0);
	store(dout_addr[2], 0x2000, 4096, 0, 0, 0, 0, 0);
}


#define BOUND 10000
volatile int data[2048];
volatile int data0[2048];
volatile int dfx[2048];
volatile int dfy[2048];
volatile int z[2048];
volatile int dfx_i[2048];
volatile int dfy_i[2048];
volatile int z_i[2048];
#define  BlockSize 32
#define  x_length 32
void kernel()
{
	for (int i = 0; i < BlockSize; i++)
	{
		for (int j = 0; j < BlockSize; j++)
		{
			int temp_dfx=0;
			int temp_dfy=0;
			int temp_ixj = data[i*(x_length) + j];
			int temp_ixj1 = data[i*(x_length) + j + 1];
			int temp_ixjs1 = data[i*(x_length) + j - 1];
			int temp_i1xj = data[(i + 1)*(x_length) + j];
			int temp_is1xj = data[(i - 1)*(x_length) + j];
			if (j == 0){
				temp_dfx = (temp_ixj1 - temp_ixj);
			}else if (j == (BlockSize - 1)){
				temp_dfx = (temp_ixj - temp_ixjs1);
			}else{
				temp_dfx = (temp_ixj1 - temp_ixjs1)*2;
			}
			if (i == 0){
				temp_dfy = (temp_i1xj - temp_ixj);
			}else if (i == (BlockSize - 1)){
				temp_dfy = (temp_ixj - data[(i - 1)*(x_length) + j]);
			}else{
				temp_dfy = (temp_i1xj - data[(i - 1)*(x_length) + j]) * 2;
			}
			dfx_i[i*BlockSize + j]= temp_dfx;
			dfy_i[i*BlockSize + j] = temp_dfy;
			z_i[i*BlockSize + j] = data0[i*(x_length) + j] - temp_ixj;
			//z[i] = j;
		}
	}
}

void result_check()
{
  	for (int i=0 ; i < 2048 ; i++) {
    	if (dfx_i[i] != dfx[i]) printf("There is an error in location (%d)[%d, %d]\n", i, dfx_i[i], dfx[i]);
        if (dfy_i[i] != dfy[i]) printf("There is an error in location (%d)[%d, %d]\n", i, dfy_i[i], dfy[i]);
        if (z_i[i] != z[i]) printf("There is an error in location (%d)[%d, %d]\n", i, z_i[i], z[i]);
  	}
}


int main(){

//   int i,j;
  	long long unsigned start;
  	long long unsigned end;

    for (int i=0 ; i < 2048 ; i++) {
		data[i] = 2*i;
		data0[i] = i;
		z[i] = 0;
        z_i[i] = 0;
        dfx[i] = 0;
		dfx_i[i] = 0;
        dfy[i] = 0;
        dfy_i[i] = 0;
	}
  	printf("Initialization finished!\n");
  
	printf("CPU add finished!\n");
  	start = rdcycle();
  	/* Run kernel. */
  	kernel();
  	end = rdcycle();
  	printf("It takes %d cycles for CPU to finish the task.\n", end - start);
 
    void* cgra_din_addr[2] = {data, data0};
    void* cgra_dout_addr[3] = {dfx, dfy, z};

  	start = rdcycle();
  	cgra_execute(cgra_din_addr, cgra_dout_addr);
  	volatile int result = fence(1);
  	end = rdcycle();
  	printf("It takes %d cycles for CGRA to finish the task(%d).\n", end - start, 1);
  	printf("CGRA comput finished!\n");
  	result = fence(1);
    
  	printf("Checking results!\n");
  	result_check();
  	printf("Done!\n");

	return 0;

}
