#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include benchmark-specific header. */
#include "include/encoding.h"
#include "include/ISA.h"
#define TYPE int
#define N 64
#define SIZE 4096
#define NI 64
#define NJ 64
#define ROW 16
#define COL 16
#define HEI 16

//// ################################ ellpack ##########################################
//#define ellpackN 494
//#define ellpackL 8
//TYPE nzval[ellpackN*ellpackL] __attribute__((aligned(16)));
//TYPE cols[ellpackN*ellpackL] __attribute__((aligned(16)));
//TYPE vec[ellpackN] __attribute__((aligned(16)));
//TYPE out[ellpackN] __attribute__((aligned(16)));
////TYPE res[ellpackN] __attribute__((aligned(16)));
//
//void ellpack()
//{
//    int i, j;
//    TYPE Si;
//
//    ellpack_1 : for (i=0; i<ellpackN; i++) {
//        TYPE sum = 0;
//        ellpack_2 : for (j=0; j<ellpackL; j++) {
////        please_map_me();
//                Si = nzval[j + i*ellpackL] * vec[cols[j + i*ellpackL]];
//                sum += Si;
//        }
//        out[i] += sum;
//    }
//}
//
//void ellpack_cgra_execute(void** din_addr, void** dout_addr)
//{
//	static unsigned short cin[27][5] __attribute__((aligned(16))) = {
//		{0x0000, 0x8000, 0x0200, 0xf700, 0x0008},
//		{0x0000, 0x8000, 0x004c, 0x0000, 0x0009},
//		{0x4000, 0x8000, 0x0200, 0xf700, 0x000c},
//		{0x0000, 0x8000, 0x0000, 0x0000, 0x000d},
//		{0x0030, 0x0000, 0x0000, 0x0000, 0x001a},
//		{0x0000, 0x0010, 0x0000, 0x0000, 0x001e},
//		{0x0000, 0x0020, 0x0000, 0x0000, 0x003e},
//		{0x0000, 0x0600, 0x0000, 0x0000, 0x0042},
//		{0x0000, 0x0000, 0x3011, 0x0000, 0x0054},
//		{0x0000, 0x0004, 0x0104, 0x07b8, 0x0055},
//		{0xc000, 0x0008, 0x0000, 0x0000, 0x0062},
//		{0x0000, 0x0003, 0x0000, 0x0000, 0x0064},
//		{0x8010, 0x0000, 0x0000, 0x0000, 0x0066},
//		{0x0000, 0x0000, 0x3101, 0x0001, 0x0072},
//		{0x0000, 0x0000, 0x3603, 0x0001, 0x0076},
//		{0x0030, 0x0000, 0x0000, 0x0000, 0x0084},
//		{0x0030, 0x0000, 0x0000, 0x0000, 0x0088},
//		{0x0004, 0x0000, 0x3003, 0x0000, 0x0098},
//		{0x0000, 0x0004, 0x0000, 0x0000, 0x00a8},
//		{0x0110, 0x0000, 0x0000, 0x0000, 0x00aa},
//		{0x0000, 0x0004, 0x0000, 0x0000, 0x00ac},
//		{0x1000, 0x8000, 0x0200, 0xf700, 0x00b8},
//		{0x0000, 0x8000, 0x0003, 0x0000, 0x00b9},
//		{0x4000, 0x8000, 0x0200, 0xf700, 0x00ba},
//		{0x0000, 0x8000, 0x0000, 0x0000, 0x00bb},
//		{0x2000, 0x0000, 0x00f7, 0x0000, 0x00bc},
//		{0x0000, 0x8000, 0x0084, 0x0000, 0x00bd},
//	};
//
//	load_cfg((void*)cin, 0x40000, 270, 0, 0);
//	load_data(din_addr[0], 0x20000, 15808, 0, 0, 0);
//	load_data(din_addr[1], 0x10000, 15808, 0, 0, 0);
//	load_data(din_addr[2], 0x24000, 1976, 0, 0, 0);
//	load_data(din_addr[3], 0x28000, 1976, 0, 0, 0);
//	config(0x0, 27, 0, 0);
//	execute(0xe28, 0, 0);
//	store(dout_addr[0], 0x0, 1976, 0, 0);
//}


// ################################ gesummv ##########################################

TYPE gesummv_A[N][N] __attribute__((aligned(16)));
TYPE gesummv_B[N][N] __attribute__((aligned(16)));
TYPE gesummv_x[N] __attribute__((aligned(16)));
TYPE gesummv_y[N] __attribute__((aligned(16)));
//TYPE yy[N] __attribute__((aligned(16)));

void gesummv()
{
  int i, j;
  TYPE alpha = 3;
  TYPE beta = 2;

  for (i = 0; i < N; i++)
  {
    TYPE sum0 = 0;
    TYPE sum1 = 0;
    for (j = 0; j < N; j++)
    {
//      please_map_me();
      sum0 += gesummv_A[i][j] * gesummv_x[j];
      sum1 += gesummv_B[i][j] * gesummv_x[j];
    }
    gesummv_y[i] = alpha * sum0 + beta * sum1;
  }

}


// ################################ stencil3d ##########################################

#define INDX(_ROW,_COL,_i,_j,_k) ((_i)+_ROW*((_j)+_COL*(_k)))

TYPE stencil3d_C[2] __attribute__((aligned(16)));
TYPE stencil3d_orig[SIZE] __attribute__((aligned(16)));
TYPE stencil3d_sol[SIZE] __attribute__((aligned(16)));
//TYPE res[SIZE];

void stencil3d (){
    int i,j,k;
	int sum0, sum1, mul0, mul1;

	for(i = 1; i < HEI - 1; i++){
        for(j = 1; j < COL - 1; j++){
            for(k = 1; k < ROW - 1; k++){

                sum0 = stencil3d_orig[INDX(ROW, COL, k, j, i)];
                sum1 = stencil3d_orig[INDX(ROW, COL, k, j, i + 1)] +
                       stencil3d_orig[INDX(ROW, COL, k, j, i - 1)] +
                       stencil3d_orig[INDX(ROW, COL, k, j + 1, i)] +
                       stencil3d_orig[INDX(ROW, COL, k, j - 1, i)] +
                       stencil3d_orig[INDX(ROW, COL, k + 1, j, i)] +
                       stencil3d_orig[INDX(ROW, COL, k - 1, j, i)];
                mul0 = sum0 * stencil3d_C[0];
                mul1 = sum1 * stencil3d_C[1];
                stencil3d_sol[INDX(ROW, COL, k, j, i)] = mul0 + mul1;
            }
        }
    }
}


// ################################ mvt ##########################################
int mvt_A[N][N] __attribute__((aligned(16)));
int mvt_x1[N] __attribute__((aligned(16)));
int mvt_x2[N] __attribute__((aligned(16)));
int mvt_y_1[N] __attribute__((aligned(16)));
int mvt_y_2[N] __attribute__((aligned(16)));


void kernel_mvt()
{
  int i, j ,s1, s2;

  for (i = 0; i < N; i++)
  {
    s1 = 0;
    s2 = 0;
    for (j = 0; j < N; j++)
    {
        s1 += mvt_A[i][j] * mvt_y_1[j];
        s2 += mvt_A[j][i] * mvt_y_2[j];
    }
    mvt_x1[i] += s1;
    mvt_x2[i] += s2;
  }
}


// ################################ conv2d_3x3 ##########################################

int conv2d_3x3_A[SIZE] __attribute__((aligned(16)));
int conv2d_3x3_B[SIZE] __attribute__((aligned(16)));
int conv2d_3x3_C[SIZE] __attribute__((aligned(16)));

/*For 3x3 filter*/
#define c11 2
#define c12 -3
#define c21 5
#define c22 6
#define c13 4
#define c23 7
#define c31 -8
#define c32 -9
#define c33 10


void conv2d_3x3() {
	for (int i = 1; i < NI -1; i++) {
		for (int j = 1; j < NJ-1; j++) {
            #ifdef CGRA_COMPILER
            please_map_me();
            #endif
	        /*For 3x3 filter*/
		    conv2d_3x3_C[i*NJ + j] = c11 * conv2d_3x3_A[(i - 1)*NJ + (j - 1)]  +  c12 * conv2d_3x3_A[(i + 0)*NJ + (j - 1)]  +  c13 * conv2d_3x3_A[(i + 1)*NJ + (j - 1)]
				+ c21 * conv2d_3x3_A[(i - 1)*NJ + (j + 0)]  +  c22 * conv2d_3x3_A[(i + 0)*NJ + (j + 0)]  +  c23 * conv2d_3x3_A[(i + 1)*NJ + (j + 0)]
				+ c31 * conv2d_3x3_A[(i - 1)*NJ + (j + 1)]  +  c32 * conv2d_3x3_A[(i + 0)*NJ + (j + 1)]  +  c33 * conv2d_3x3_A[(i + 1)*NJ + (j + 1)];
		}
	}
}



// ################################ fir ##########################################
#define NTAPS 8

int fir_input[SIZE] __attribute__((aligned(16)));
int fir_output[SIZE] __attribute__((aligned(16)));
int fir_coefficients[NTAPS] __attribute__((aligned(16))) = {
025, 150, 375, -225, 050, 075, -300, 125};


void fir()//(int input[], int output[], int coefficients[])
/*   input :           input sample array */
/*   output:           output sample array */
/*   coefficient:      coefficient array */
{
   int i, j;

   for(j=0; j< SIZE; ++j) {
 	  int sum = 0;
    //#pragma unroll 4
    for (i = 0; i < NTAPS; ++i) {
      #ifdef CGRA_COMPILER
      please_map_me();
      #endif
      if(i<=j){
        sum += fir_input[j-i] * fir_coefficients[i];
      }
    }
    fir_output[j] = sum;
 }
}


// ################################ pedometer ##########################################

int acc_vector[SIZE] __attribute__((aligned(16)));
//int res_vector[SIZE] __attribute__((aligned(16)));
int acceleration_x[SIZE] __attribute__((aligned(16)));
int acceleration_y[SIZE] __attribute__((aligned(16)));
int acceleration_z[SIZE] __attribute__((aligned(16)));
int acc_avg_x[SIZE] __attribute__((aligned(16)));
int acc_avg_y[SIZE] __attribute__((aligned(16)));
int acc_avg_z[SIZE] __attribute__((aligned(16)));

/* Main computational kernel. The whole function will be timed,
   including the call and return. */

void pedometer(){
	for(int i=0;i<SIZE;i++){
	    int sub_x = acceleration_x[i]- acc_avg_x[i];
        int sub_y = acceleration_y[i]- acc_avg_y[i];
        int sub_z = acceleration_z[i]-acc_avg_z[i];
        acc_vector[i] = sub_x * sub_x+  sub_y * sub_y+ sub_z * sub_z;
//		acc_vector[i] = (acceleration_x[i]- acc_avg_x[i]) * (acceleration_x[i]- acc_avg_x[i])+  (acceleration_y[i]- acc_avg_y[i]) * (acceleration_y[i]- acc_avg_y[i])+ (acceleration_z[i]-acc_avg_z[i]) * (acceleration_z[i]-acc_avg_z[i]) ;
	}
}


// ################################ stencil2d ##########################################
#define f_size 9

TYPE stencil2d_orig[NI * NJ] __attribute__((aligned(16)));
TYPE stencil2d_sol[NI * NJ] __attribute__((aligned(16)));
TYPE stencil2d_filter[f_size] __attribute__((aligned(16)));
//TYPE stencil2d_res[NI * NJ] __attribute__((aligned(16)));


void stencil2d(){
    int r, c, k1, k2;
    TYPE temp, mul;

    for (r=0; r<NI-2; r++) {
        for (c=0; c<NJ-2; c++) {
            temp = (TYPE)0;
            for (k1=0;k1<3;k1++){
                #pragma unroll
                for (k2=0;k2<3;k2++){
                    mul = stencil2d_filter[k1*3 + k2] * stencil2d_orig[(r+k1)*NJ + c+k2];
                    temp += mul;
                }
            }
            stencil2d_sol[(r*NJ) + c] = temp;
        }
    }
}


// ################################ fft ##########################################

#define FFT_N 4096

TYPE XR0[FFT_N] __attribute__((aligned(16)));
TYPE XR1[FFT_N] __attribute__((aligned(16)));
TYPE XR2[FFT_N] __attribute__((aligned(16)));
TYPE XR3[FFT_N] __attribute__((aligned(16)));
TYPE XI0[FFT_N] __attribute__((aligned(16)));
TYPE XI1[FFT_N] __attribute__((aligned(16)));
TYPE XI2[FFT_N] __attribute__((aligned(16)));
TYPE XI3[FFT_N] __attribute__((aligned(16)));
TYPE YR0[FFT_N] __attribute__((aligned(16)));
TYPE YR1[FFT_N] __attribute__((aligned(16)));
TYPE YR2[FFT_N] __attribute__((aligned(16)));
TYPE YR3[FFT_N] __attribute__((aligned(16)));
TYPE YI0[FFT_N] __attribute__((aligned(16)));
TYPE YI1[FFT_N] __attribute__((aligned(16)));
TYPE YI2[FFT_N] __attribute__((aligned(16)));
TYPE YI3[FFT_N] __attribute__((aligned(16)));
//TYPE ZR0[FFT_N] __attribute__((aligned(16)));
//TYPE ZR1[FFT_N] __attribute__((aligned(16)));
//TYPE ZR2[FFT_N] __attribute__((aligned(16)));
//TYPE ZR3[FFT_N] __attribute__((aligned(16)));
//TYPE ZI0[FFT_N] __attribute__((aligned(16)));
//TYPE ZI1[FFT_N] __attribute__((aligned(16)));
//TYPE ZI2[FFT_N] __attribute__((aligned(16)));
//TYPE ZI3[FFT_N] __attribute__((aligned(16)));


#define cmplx_M_x(a_x, a_y, b_x, b_y) (a_x*b_x - a_y *b_y)
#define cmplx_M_y(a_x, a_y, b_x, b_y) (a_x*b_y + a_y *b_x)
#define cmplx_MUL_x(a_x, a_y, b_x, b_y ) (a_x*b_x - a_y*b_y)
#define cmplx_MUL_y(a_x, a_y, b_x, b_y ) (a_x*b_y + a_y*b_x)
#define cmplx_mul_x(a_x, a_y, b_x, b_y) (a_x*b_x - a_y*b_y)
#define cmplx_mul_y(a_x, a_y, b_x, b_y) (a_x*b_y + a_y*b_x)
#define cmplx_add_x(a_x, b_x) (a_x + b_x)
#define cmplx_add_y(a_y, b_y) (a_y + b_y)
#define cmplx_sub_x(a_x, b_x) (a_x - b_x)
#define cmplx_sub_y(a_y, b_y) (a_y - b_y)
#define cm_fl_mul_x(a_x, b) (b*a_x)
#define cm_fl_mul_y(a_y, b) (b*a_y)

#define FF2(a0_x, a0_y, a1_x, a1_y){			\
    TYPE c0_x = a0_x;		\
    TYPE c0_y = a0_y;		\
    a0_x = cmplx_add_x(c0_x, a1_x);	\
    a0_y = cmplx_add_y(c0_y, a1_y);	\
    a1_x = cmplx_sub_x(c0_x, a1_x);	\
    a1_y = cmplx_sub_y(c0_y, a1_y);	\
}

#define FFT4(a0_x, a0_y, a1_x, a1_y, a2_x, a2_y, a3_x, a3_y){           \
    TYPE exp_1_44_x;		\
    TYPE exp_1_44_y;		\
    TYPE tmp;			\
    exp_1_44_x =  0;		\
    exp_1_44_y =  -1;		\
    FF2( a0_x, a0_y, a2_x, a2_y);   \
    FF2( a1_x, a1_y, a3_x, a3_y);   \
    tmp = a3_x;			\
    a3_x = a3_x*exp_1_44_x-a3_y*exp_1_44_y;     	\
    a3_y = tmp*exp_1_44_y - a3_y*exp_1_44_x;    	\
    FF2( a0_x, a0_y, a1_x, a1_y );                  \
    FF2( a2_x, a2_y, a3_x, a3_y );                  \
}


void fft4(){
    int i;
    for(i = 0; i < FFT_N; i++){
//    please_map_me();
        TYPE a0_x = XR0[i];
        TYPE a0_y = XI0[i];
        TYPE a1_x = XR1[i];
        TYPE a1_y = XI1[i];
        TYPE a2_x = XR2[i];
        TYPE a2_y = XI2[i];
        TYPE a3_x = XR3[i];
        TYPE a3_y = XI3[i];
        FFT4(a0_x, a0_y, a1_x, a1_y, a2_x, a2_y, a3_x, a3_y);
        YR0[i] = a0_x;
        YI0[i] = a0_y;
        YR1[i] = a1_x;
        YI1[i] = a1_y;
        YR2[i] = a2_x;
        YI2[i] = a2_y;
        YR3[i] = a3_x;
        YI3[i] = a3_y;
    }
}


// ################################ gemm-unroll4 ##########################################
#define row_size 64
#define col_size 64
//#define N row_size*col_size

TYPE gemm_m1[row_size][col_size] __attribute__((aligned(16)));
TYPE gemm_m2[col_size][row_size] __attribute__((aligned(16)));
//TYPE gemm_prod0[SIZE] __attribute__((aligned(16)));
TYPE gemm_prod[row_size][row_size] __attribute__((aligned(16)));

void gemm(){
    int i, j, k;
    int k_col, i_col;
    TYPE mult;

    outer:for(i=0;i<row_size;i++) {
        middle:for(j=0;j<row_size;j++) {
            i_col = i * col_size;
            TYPE sum = 0;
            #pragma unroll 4
            for(k=0;k<col_size;k++) {
//            please_map_me();
                k_col = k * row_size;
                mult = gemm_m1[i][k] * gemm_m2[k][j]; // m1[i_col + k] * m2[k_col + j]; //
                sum += mult;
            }
            gemm_prod[i][j]  = sum;
        }
    }
}


void fir_cgra_execute(void** din_addr, void** dout_addr)
{
	static unsigned short cin[26][5] __attribute__((aligned(16))) = {
		{0x8000, 0x3fff, 0x8002, 0x0000, 0x0010},
		{0x0080, 0x0000, 0x0040, 0x0000, 0x0011},
		{0x8000, 0x0000, 0x9002, 0x07ff, 0x0014},
		{0x0080, 0x0000, 0x0040, 0x0000, 0x0015},
		{0x2000, 0x0000, 0x1002, 0x0000, 0x0018},
		{0x0080, 0x0000, 0x22c0, 0x0020, 0x0019},
		{0x0400, 0x0000, 0x0000, 0x0000, 0x0034},
		{0x0000, 0x0004, 0x0000, 0x0000, 0x0038},
		{0x0200, 0x0000, 0x0000, 0x0000, 0x003c},
		{0x0001, 0x0000, 0x0000, 0x0000, 0x0040},
		{0x0000, 0x0000, 0xa003, 0x0000, 0x0058},
		{0x0000, 0x0000, 0x1221, 0x0002, 0x0060},
		{0x0000, 0x0004, 0x0204, 0x0000, 0x0061},
		{0x0001, 0x0000, 0x0000, 0x0000, 0x0062},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0088},
		{0x0000, 0x0000, 0x4006, 0x0000, 0x00ac},
		{0x0001, 0x0000, 0x0011, 0x0000, 0x00b0},
		{0x0000, 0x0004, 0x0200, 0x0000, 0x00b1},
		{0x0005, 0x0000, 0x0000, 0x0000, 0x00b2},
		{0x0001, 0x0000, 0x0000, 0x0000, 0x00d4},
		{0x0000, 0x0000, 0x300a, 0x0001, 0x00f4},
		{0x0000, 0x0040, 0x0000, 0x0000, 0x0114},
		{0x0020, 0x0000, 0x0000, 0x0000, 0x0118},
		{0x0001, 0x0000, 0x0011, 0x0000, 0x0134},
		{0x0000, 0x0020, 0x0000, 0x0014, 0x0135},
		{0x0004, 0x0000, 0x0000, 0x0000, 0x0136},
	};

	load_cfg((void*)cin, 0x80000, 260, 0, 0);
	load_data(din_addr[0], 0x20000, 32, 0, 0, 0);
	load_data(din_addr[1], 0x0, 16384, 0, 0, 0);
	config(0x0, 26, 0, 0);
	execute(0x38, 0, 0);
	store(dout_addr[0], 0x28000, 16384, 0, 0);
}


void stencil3d_cgra_execute(void** din_addr, void** dout_addr)
{
	static unsigned short cin[50][5] __attribute__((aligned(16))) = {
		{0x4001, 0x8000, 0x0003, 0x7000, 0x0008},
		{0x0000, 0x0e00, 0x01c0, 0x0000, 0x0009},
		{0x9001, 0x8000, 0x3003, 0x7000, 0x000c},
		{0x4600, 0x0e00, 0x0040, 0x0000, 0x000d},
		{0xa102, 0x8000, 0x3003, 0x7000, 0x0010},
		{0x4600, 0x0e00, 0x0040, 0x0000, 0x0011},
		{0x8109, 0x8000, 0x3003, 0x7000, 0x0018},
		{0x4600, 0x0e00, 0x0040, 0x0000, 0x0019},
		{0xc201, 0x8000, 0x3003, 0x7000, 0x0020},
		{0x4600, 0x0e00, 0x0040, 0x0000, 0x0021},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0030},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0034},
		{0x0000, 0x0008, 0x0000, 0x0000, 0x0038},
		{0x0200, 0x0010, 0x0000, 0x0000, 0x003c},
		{0x8000, 0x0000, 0x0000, 0x0000, 0x0040},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0044},
		{0x0000, 0x0000, 0x1001, 0x0001, 0x0060},
		{0x0300, 0x0000, 0x0000, 0x0000, 0x0078},
		{0x0c00, 0x0800, 0x0000, 0x0000, 0x0080},
		{0x0000, 0x0202, 0x0000, 0x0000, 0x0084},
		{0x0000, 0x0000, 0x1103, 0x0002, 0x009c},
		{0x0000, 0x0000, 0xc801, 0x0000, 0x00a4},
		{0x0100, 0x0000, 0x0000, 0x0000, 0x00c0},
		{0x0008, 0x0000, 0x0000, 0x0000, 0x00c4},
		{0x0000, 0x0603, 0x0000, 0x0000, 0x00c8},
		{0x2003, 0x0001, 0x0000, 0x0000, 0x00cc},
		{0x0000, 0x0000, 0x1801, 0x0002, 0x00e4},
		{0x0000, 0x0000, 0xa401, 0x0001, 0x00ec},
		{0x0000, 0x0000, 0x1801, 0x0002, 0x00f0},
		{0x0000, 0x0200, 0x0000, 0x0000, 0x0108},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x010c},
		{0x80c0, 0x0000, 0x0000, 0x0000, 0x0110},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0114},
		{0x000c, 0x0000, 0x0000, 0x0000, 0x0118},
		{0x0000, 0x0000, 0x32c3, 0x0001, 0x0130},
		{0x0000, 0x0000, 0x1601, 0x0002, 0x0138},
		{0x2000, 0x0000, 0x0000, 0x0000, 0x0150},
		{0x0010, 0x0000, 0x0000, 0x0000, 0x0154},
		{0x0000, 0x0004, 0x0000, 0x0000, 0x0158},
		{0x0004, 0x0000, 0x0000, 0x0000, 0x0160},
		{0xc001, 0x8000, 0x3003, 0x7000, 0x0170},
		{0x4600, 0x0e00, 0x26c0, 0x0020, 0x0171},
		{0x2000, 0x8000, 0x0003, 0x7000, 0x0174},
		{0x0000, 0x0e00, 0x0040, 0x0000, 0x0175},
		{0x8111, 0x8000, 0x3003, 0x7000, 0x0178},
		{0x4600, 0x0e00, 0x0040, 0x0000, 0x0179},
		{0x80f1, 0x8000, 0x3003, 0x7000, 0x0180},
		{0x4600, 0x0e00, 0x0040, 0x0000, 0x0181},
		{0xa100, 0x8000, 0x3003, 0x7000, 0x0184},
		{0x4600, 0x0e00, 0x00c0, 0x0000, 0x0185},
	};

	load_cfg((void*)cin, 0x80110, 500, 1, 0);
	load_data(din_addr[0], 0x48000, 8, 1, 1, 0);
	load_data(din_addr[1], 0x10000, 8, 0, 1, 0);
	load_data(din_addr[2], 0x20020, 16252, 1, 1, 0);
	load_data(din_addr[3], 0x30000, 16252, 1, 1, 0);
	load_data(din_addr[4], 0x4000, 16252, 1, 1, 0);
	load_data(din_addr[5], 0x40000, 16252, 1, 1, 0);
	load_data(din_addr[6], 0x60000, 16252, 1, 1, 0);
	load_data(din_addr[7], 0x8000, 16252, 1, 1, 0);
	load_data(din_addr[8], 0x68000, 16252, 0, 1, 0);
	config(0x11, 50, 1, 0);
	execute(0x6eae, 1, 0);
	store(dout_addr[0], 0x50000, 14204, 1, 0);
}


void gesummv_cgra_execute(void** din_addr, void** dout_addr)
{
	static unsigned short cin[28][5] __attribute__((aligned(16))) = {
		{0x0000, 0x0000, 0x1010, 0x0000, 0x0018},
		{0x0002, 0x0000, 0x23c0, 0x0000, 0x0019},
		{0x0030, 0x0000, 0x0000, 0x0000, 0x003c},
		{0x1000, 0x0008, 0x0000, 0x0000, 0x0084},
		{0x0003, 0x0000, 0x4003, 0x0000, 0x00a0},
		{0x0000, 0x0000, 0xa001, 0x0001, 0x00a4},
		{0x0001, 0x0000, 0x4007, 0x0000, 0x00a8},
		{0x0001, 0x0000, 0x0000, 0x0000, 0x00c8},
		{0x0001, 0x0000, 0x0000, 0x0000, 0x00d0},
		{0x0000, 0x0000, 0x4011, 0x0000, 0x00e8},
		{0x0000, 0x0004, 0x1004, 0x0400, 0x00e9},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x00ea},
		{0x0000, 0x0000, 0x4011, 0x0000, 0x00f0},
		{0x0000, 0x0004, 0x1004, 0x0400, 0x00f1},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x00f2},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0110},
		{0x0001, 0x0000, 0x0000, 0x0000, 0x0118},
		{0x0000, 0x0000, 0xc003, 0x0001, 0x0134},
		{0x0000, 0x0000, 0x4003, 0x0002, 0x0138},
		{0x0040, 0x0000, 0x0000, 0x0000, 0x0158},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x015c},
		{0x0004, 0x0000, 0x0000, 0x0000, 0x0160},
		{0x8fe0, 0x0000, 0x1010, 0x0000, 0x0178},
		{0x0002, 0x0000, 0x0040, 0x0000, 0x0179},
		{0xafe0, 0x0000, 0x1010, 0x07fc, 0x0180},
		{0x0002, 0x0000, 0x0040, 0x0000, 0x0181},
		{0x8fe0, 0x0000, 0x1010, 0x0000, 0x0184},
		{0x0002, 0x0000, 0x0040, 0x0000, 0x0185},
	};

	load_cfg((void*)cin, 0x80310, 280, 2, 0);
	load_data(din_addr[0], 0x43f80, 16384, 0, 2, 0);
	load_data(din_addr[1], 0x63f80, 16384, 0, 2, 0);
	load_data(din_addr[2], 0x6bf80, 256, 0, 2, 0);
	config(0x31, 28, 2, 0);
	execute(0x6820, 2, 0);
	store(dout_addr[0], 0x20000, 256, 2, 0);
}


void conv2d_3x3_cgra_execute(void** din_addr, void** dout_addr)
{
	static unsigned short cin[61][5] __attribute__((aligned(16))) = {
		{0xa002, 0x8000, 0x300f, 0xf000, 0x0008},
		{0x0001, 0x0000, 0x0040, 0x0000, 0x0009},
		{0x8080, 0x8000, 0x300f, 0xf000, 0x000c},
		{0x0001, 0x0000, 0x0040, 0x0000, 0x000d},
		{0xc042, 0x8000, 0x300f, 0xf000, 0x0010},
		{0x0001, 0x0000, 0x0040, 0x0000, 0x0011},
		{0xe082, 0x8000, 0x300f, 0xf000, 0x0014},
		{0x0001, 0x0000, 0x0040, 0x0000, 0x0015},
		{0x8041, 0x8000, 0x300f, 0xf000, 0x0018},
		{0x0001, 0x0000, 0x26c0, 0x0000, 0x0019},
		{0xa040, 0x8000, 0x300f, 0xf000, 0x001c},
		{0x0001, 0x0000, 0x0040, 0x0000, 0x001d},
		{0xc081, 0x8000, 0x300f, 0xf000, 0x0020},
		{0x0001, 0x0000, 0x0040, 0x0000, 0x0021},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x002c},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0030},
		{0x4000, 0x0000, 0x0000, 0x0000, 0x0038},
		{0x0030, 0x0000, 0x0000, 0x0000, 0x003c},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0044},
		{0xfff8, 0xffff, 0x2083, 0x0000, 0x004c},
		{0x0002, 0x0000, 0x2007, 0x0000, 0x0050},
		{0x0000, 0x0000, 0xc401, 0x0001, 0x0054},
		{0x0000, 0x0000, 0x3801, 0x0001, 0x0058},
		{0xfff7, 0xffff, 0x10c3, 0x0000, 0x005c},
		{0x000a, 0x0000, 0x1103, 0x0000, 0x0060},
		{0x0007, 0x0000, 0x2003, 0x0000, 0x0064},
		{0xfffd, 0xffff, 0x1003, 0x0000, 0x0068},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0074},
		{0x0800, 0x0000, 0x0000, 0x0000, 0x0078},
		{0x0010, 0x0000, 0x0000, 0x0000, 0x007c},
		{0x3000, 0x0000, 0x0000, 0x0000, 0x0080},
		{0x0000, 0x000b, 0x0000, 0x0000, 0x0084},
		{0x0000, 0x0203, 0x0000, 0x0000, 0x0088},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x008c},
		{0x0000, 0x0000, 0xc801, 0x0000, 0x009c},
		{0x0000, 0x0000, 0xa001, 0x0001, 0x00a0},
		{0x0000, 0x0000, 0x1801, 0x0001, 0x00a4},
		{0x0000, 0x0100, 0x0000, 0x0000, 0x00c0},
		{0x0382, 0x0000, 0x0000, 0x0000, 0x00c4},
		{0x0000, 0x0001, 0x0000, 0x0000, 0x00c8},
		{0xc000, 0x0000, 0x0000, 0x0000, 0x00cc},
		{0x0000, 0x0002, 0x0000, 0x0000, 0x00d0},
		{0x0000, 0x0000, 0x1601, 0x0002, 0x00e8},
		{0x0000, 0x0000, 0x3801, 0x0001, 0x00ec},
		{0x0000, 0x0008, 0x0000, 0x0000, 0x0108},
		{0x0100, 0x0000, 0x0000, 0x0000, 0x010c},
		{0x0018, 0x0000, 0x0000, 0x0000, 0x0110},
		{0x0000, 0x0001, 0x0000, 0x0000, 0x0114},
		{0x0001, 0x0000, 0x3007, 0x0000, 0x0128},
		{0x0006, 0x0000, 0x4003, 0x0000, 0x012c},
		{0x0000, 0x0000, 0x9801, 0x0001, 0x0130},
		{0x0005, 0x0000, 0x3003, 0x0000, 0x0138},
		{0x0010, 0x0000, 0x0000, 0x0000, 0x014c},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0154},
		{0x0010, 0x0000, 0x0000, 0x0000, 0x015c},
		{0xa000, 0x8000, 0x300f, 0xf000, 0x016c},
		{0x0001, 0x0000, 0x0040, 0x0000, 0x016d},
		{0xe041, 0x8000, 0x300f, 0xf000, 0x0178},
		{0x0001, 0x0000, 0x0040, 0x0000, 0x0179},
		{0xc001, 0x8000, 0x300f, 0xf000, 0x017c},
		{0x0001, 0x0000, 0x0040, 0x0000, 0x017d},
	};

	load_cfg((void*)cin, 0x80430, 610, 3, 0);
	load_data(din_addr[0], 0x48000, 16384, 1, 3, 0);
	load_data(din_addr[1], 0x28000, 16384, 1, 3, 0);
	load_data(din_addr[2], 0x0, 16384, 1, 3, 0);
	load_data(din_addr[3], 0x70000, 16384, 1, 3, 0);
	load_data(din_addr[4], 0x58000, 16384, 1, 3, 0);
	load_data(din_addr[5], 0x30000, 16384, 1, 3, 0);
	load_data(din_addr[6], 0x8000, 16384, 1, 3, 0);
	load_data(din_addr[7], 0x10000, 16384, 1, 3, 0);
	load_data(din_addr[8], 0x38000, 16384, 0, 3, 0);
	config(0x43, 61, 3, 0);
	execute(0x19fe, 3, 0);
	store(dout_addr[0], 0x20100, 15868, 3, 0);
}



void mvt_cgra_execute(void** din_addr, void** dout_addr)
{
	static unsigned short cin[42][5] __attribute__((aligned(16))) = {
		{0x5000, 0x0000, 0x1010, 0x0000, 0x0014},
		{0x0002, 0x0000, 0x0040, 0x0000, 0x0015},
		{0x0fc0, 0x0000, 0x1010, 0x0000, 0x0018},
		{0x0002, 0x0000, 0x2340, 0x0000, 0x0019},
		{0xb000, 0x0000, 0x1010, 0x07fc, 0x0020},
		{0x0002, 0x0000, 0x0040, 0x0000, 0x0021},
		{0x0100, 0x0000, 0x0000, 0x0000, 0x0038},
		{0x0010, 0x0000, 0x0000, 0x0000, 0x003c},
		{0x0000, 0x0010, 0x0000, 0x0000, 0x0044},
		{0x0000, 0x0000, 0x9081, 0x0001, 0x005c},
		{0x00c0, 0x0000, 0x0000, 0x0000, 0x0080},
		{0x0000, 0x0600, 0x0000, 0x0000, 0x008c},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x00c8},
		{0x1000, 0x0000, 0x0000, 0x0000, 0x00d0},
		{0x2000, 0x0000, 0x0000, 0x0000, 0x00d4},
		{0x0000, 0x0000, 0x3011, 0x0000, 0x00ec},
		{0x0000, 0x0004, 0x1004, 0x0400, 0x00ed},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x00ee},
		{0x0000, 0x0000, 0x2011, 0x0000, 0x00f0},
		{0x0000, 0x0004, 0x1005, 0x0400, 0x00f1},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x00f2},
		{0x0000, 0x0000, 0xa203, 0x0001, 0x00f4},
		{0x0010, 0x0000, 0x0000, 0x0000, 0x0110},
		{0x0400, 0x0000, 0x0000, 0x0000, 0x0114},
		{0x00c0, 0x0000, 0x0000, 0x0000, 0x0118},
		{0x0000, 0x0000, 0x3003, 0x0002, 0x0130},
		{0x0000, 0x0000, 0xb0c1, 0x0000, 0x0138},
		{0x0000, 0x0010, 0x0000, 0x0000, 0x0150},
		{0x0020, 0x0000, 0x0000, 0x0000, 0x0154},
		{0x0004, 0x0000, 0x0000, 0x0000, 0x0158},
		{0x0010, 0x0000, 0x0000, 0x0000, 0x015c},
		{0x0000, 0x0004, 0x0000, 0x0000, 0x0160},
		{0xb000, 0x0000, 0x1010, 0x07fc, 0x0170},
		{0x0002, 0x0000, 0x0040, 0x0000, 0x0171},
		{0x8000, 0x0000, 0x1010, 0x0000, 0x0178},
		{0x0002, 0x0000, 0x0040, 0x0000, 0x0179},
		{0x2000, 0x0000, 0x1010, 0x0000, 0x017c},
		{0x0002, 0x0000, 0x0040, 0x0000, 0x017d},
		{0x0000, 0x0020, 0x1010, 0x0704, 0x0180},
		{0x0002, 0x0000, 0x0040, 0x0000, 0x0181},
		{0x4000, 0x0000, 0x1010, 0x0000, 0x0184},
		{0x0002, 0x0000, 0x23c0, 0x0000, 0x0185},
	};

	load_cfg((void*)cin, 0x80000, 420, 4, 0);
	load_data(din_addr[0], 0x40000, 16384, 1, 4, 0);
	load_data(din_addr[1], 0x60000, 16384, 0, 4, 0);
	load_data(din_addr[2], 0x34000, 256, 0, 4, 0);
	load_data(din_addr[3], 0x68000, 256, 0, 4, 0);
	load_data(din_addr[4], 0x4c000, 256, 0, 4, 0);
	load_data(din_addr[5], 0x2c000, 256, 0, 4, 0);
	config(0x0, 42, 4, 0);
	execute(0x7ab0, 4, 0);
	store(dout_addr[0], 0x23f00, 256, 4, 0);
	store(dout_addr[1], 0x70000, 256, 4, 0);
}


void pedometer_cgra_execute(void** din_addr, void** dout_addr)
{
	static unsigned short cin[41][5] __attribute__((aligned(16))) = {
		{0xa000, 0x0000, 0x0400, 0x0000, 0x0008},
		{0x0000, 0x0000, 0x0040, 0x0000, 0x0009},
		{0x8000, 0x0000, 0x0400, 0x0000, 0x0010},
		{0x0000, 0x0000, 0x0040, 0x0000, 0x0011},
		{0xa000, 0x0000, 0x0400, 0x0000, 0x0018},
		{0x0000, 0x0000, 0x0040, 0x0000, 0x0019},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0030},
		{0x5000, 0x0000, 0x0000, 0x0000, 0x0038},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x003c},
		{0x0000, 0x0000, 0x2003, 0x0001, 0x0058},
		{0x0000, 0x0000, 0xa002, 0x0000, 0x005c},
		{0x0000, 0x0000, 0x4003, 0x0002, 0x0060},
		{0x0000, 0x00c0, 0x0000, 0x0000, 0x0078},
		{0x0000, 0x0080, 0x0000, 0x0000, 0x007c},
		{0x0000, 0x0080, 0x0000, 0x0000, 0x0080},
		{0x0000, 0x0080, 0x0000, 0x0000, 0x0084},
		{0x0200, 0x0000, 0x0000, 0x0000, 0x0088},
		{0x0000, 0x0000, 0x1081, 0x0001, 0x00a4},
		{0x0000, 0x0000, 0x1202, 0x0002, 0x00ac},
		{0x3000, 0x0000, 0x0000, 0x0000, 0x00c4},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x00c8},
		{0x000c, 0x0000, 0x0000, 0x0000, 0x00d4},
		{0x0000, 0x0000, 0x4003, 0x0002, 0x00e0},
		{0x0000, 0x0000, 0xa401, 0x0001, 0x00e4},
		{0x0000, 0x0200, 0x0000, 0x0000, 0x0108},
		{0x0000, 0x0020, 0x0000, 0x0000, 0x011c},
		{0x0000, 0x0000, 0xc202, 0x0001, 0x012c},
		{0x0340, 0x0000, 0x0000, 0x0000, 0x0150},
		{0x0002, 0x0000, 0x0000, 0x0000, 0x0154},
		{0x0000, 0x0003, 0x0000, 0x0000, 0x0158},
		{0x0000, 0x0003, 0x0000, 0x0000, 0x015c},
		{0x0000, 0x0001, 0x0000, 0x0000, 0x0160},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0164},
		{0x9000, 0x0000, 0x0400, 0x0000, 0x0170},
		{0x0000, 0x0000, 0x0040, 0x0000, 0x0171},
		{0xa000, 0x0000, 0x0400, 0x0000, 0x0174},
		{0x0000, 0x0000, 0x2540, 0x0000, 0x0175},
		{0xa040, 0x0000, 0x0400, 0x0000, 0x0184},
		{0x0000, 0x0000, 0x0040, 0x0000, 0x0185},
		{0x9000, 0x0000, 0x0400, 0x0000, 0x0188},
		{0x0000, 0x0000, 0x0040, 0x0000, 0x0189},
	};

	load_cfg((void*)cin, 0x801b0, 410, 5, 0);
	load_data(din_addr[0], 0x64000, 16384, 0, 5, 0);
	load_data(din_addr[1], 0x0, 16384, 0, 5, 0);
	load_data(din_addr[2], 0x44000, 16384, 0, 5, 0);
	load_data(din_addr[3], 0x8000, 16384, 0, 5, 0);
	load_data(din_addr[4], 0x28000, 16384, 0, 5, 0);
	load_data(din_addr[5], 0x68100, 16384, 0, 5, 0);
	config(0x1b, 41, 5, 0);
	execute(0xc62a, 5, 0);
	store(dout_addr[0], 0x48000, 16384, 5, 0);
}



void stencil2d_cgra_execute(void** din_addr, void** dout_addr)
{
	static unsigned short cin[37][5] __attribute__((aligned(16))) = {
		{0x9002, 0xc001, 0xa000, 0xf7ff, 0x000c},
		{0xf401, 0x3eff, 0x0040, 0x0000, 0x000d},
		{0x3002, 0xc020, 0x1000, 0xf7f8, 0x0018},
		{0x0601, 0x3eff, 0x0040, 0x0000, 0x0019},
		{0xc000, 0xc001, 0xa000, 0xf7ff, 0x001c},
		{0xf401, 0x3eff, 0x0040, 0x0000, 0x001d},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0034},
		{0x2000, 0x0000, 0x0000, 0x0000, 0x0038},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x003c},
		{0x0000, 0x0010, 0x0000, 0x0000, 0x0040},
		{0x0000, 0x0000, 0xa203, 0x0000, 0x0058},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0080},
		{0x0000, 0x0600, 0x0000, 0x0000, 0x0088},
		{0x0000, 0x0000, 0xc201, 0x0000, 0x00a4},
		{0x0400, 0x0000, 0x0000, 0x0000, 0x00c8},
		{0x0002, 0x0000, 0x0000, 0x0000, 0x00cc},
		{0x0000, 0x0604, 0x0000, 0x0000, 0x00d0},
		{0x0000, 0x0000, 0xc081, 0x0000, 0x00ec},
		{0x0001, 0x0000, 0x0000, 0x0000, 0x0114},
		{0x0c00, 0x0000, 0x0000, 0x0000, 0x0118},
		{0x0000, 0x0000, 0x3203, 0x0002, 0x0134},
		{0x0000, 0x0000, 0x1011, 0x0000, 0x0138},
		{0x0000, 0x0004, 0x00c8, 0xf040, 0x0139},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x013a},
		{0x0000, 0x0000, 0xc043, 0x0000, 0x013c},
		{0x0000, 0x0010, 0x0000, 0x0000, 0x0154},
		{0x0020, 0x0000, 0x0000, 0x0000, 0x0158},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x015c},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0164},
		{0x0001, 0xc020, 0x1000, 0xf7f8, 0x0174},
		{0x0601, 0x3eff, 0x0040, 0x0000, 0x0175},
		{0x4000, 0xc000, 0x1000, 0xf000, 0x017c},
		{0x0601, 0x3e00, 0x24c0, 0x0020, 0x017d},
		{0xb041, 0xc001, 0xa000, 0xf7ff, 0x0180},
		{0xf401, 0x3eff, 0x0040, 0x0000, 0x0181},
		{0x0000, 0xc020, 0x1000, 0xf7f8, 0x0188},
		{0x0601, 0x3eff, 0x0040, 0x0000, 0x0189},
	};

	load_cfg((void*)cin, 0x80350, 370, 6, 0);
	load_data(din_addr[0], 0x30000, 36, 1, 6, 0);
	load_data(din_addr[1], 0x6c100, 36, 1, 6, 0);
	load_data(din_addr[2], 0x4000, 36, 0, 6, 0);
	load_data(din_addr[3], 0x60000, 16384, 1, 6, 0);
	load_data(din_addr[4], 0x40000, 16384, 1, 6, 0);
	load_data(din_addr[5], 0x2c000, 16384, 0, 6, 0);
	config(0x35, 37, 6, 0);
	execute(0xb464, 6, 0);
	store(dout_addr[0], 0x70000, 15864, 6, 0);
}



void fft_cgra_execute(void** din_addr, void** dout_addr)
{
	static unsigned short cin[78][5] __attribute__((aligned(16))) = {
		{0xc000, 0x0000, 0x0400, 0x0000, 0x0004},
		{0x0000, 0x0000, 0x2340, 0x0020, 0x0005},
		{0x8000, 0x0000, 0x0400, 0x0000, 0x0008},
		{0x0000, 0x0000, 0x0040, 0x0000, 0x0009},
		{0xa000, 0x0000, 0x0400, 0x0000, 0x000c},
		{0x0000, 0x0000, 0x0040, 0x0000, 0x000d},
		{0xe000, 0x0000, 0x0400, 0x0000, 0x0010},
		{0x0000, 0x0000, 0x23c0, 0x0020, 0x0011},
		{0x8000, 0x0000, 0x0400, 0x0000, 0x0014},
		{0x0000, 0x0000, 0x0040, 0x0000, 0x0015},
		{0xa000, 0x0000, 0x0400, 0x0000, 0x0018},
		{0x0000, 0x0000, 0x0040, 0x0000, 0x0019},
		{0xc000, 0x0000, 0x0400, 0x0000, 0x001c},
		{0x0000, 0x0000, 0x2340, 0x0000, 0x001d},
		{0xe000, 0x0000, 0x0400, 0x0000, 0x0020},
		{0x0000, 0x0000, 0x23c0, 0x0000, 0x0021},
		{0x0002, 0x0000, 0x0000, 0x0000, 0x002c},
		{0x0100, 0x0003, 0x0000, 0x0000, 0x0030},
		{0x0200, 0x0000, 0x0000, 0x0000, 0x0034},
		{0x0403, 0x0000, 0x0000, 0x0000, 0x0038},
		{0x0100, 0x0000, 0x0000, 0x0000, 0x003c},
		{0x0030, 0x0000, 0x0000, 0x0000, 0x0040},
		{0x0030, 0x0000, 0x0000, 0x0000, 0x0044},
		{0x0000, 0x0000, 0x9001, 0x0000, 0x0054},
		{0x0000, 0x0000, 0x9002, 0x0000, 0x0058},
		{0x0000, 0x0000, 0xa002, 0x0000, 0x005c},
		{0x0000, 0x0000, 0x9001, 0x0000, 0x0060},
		{0x0100, 0x0200, 0x0000, 0x0000, 0x0078},
		{0x0000, 0x0200, 0x0000, 0x0000, 0x0080},
		{0x0000, 0x0400, 0x0000, 0x0000, 0x0084},
		{0x0000, 0x0100, 0x0000, 0x0000, 0x0088},
		{0x0000, 0x0010, 0x0000, 0x0000, 0x008c},
		{0x0000, 0x0000, 0x1001, 0x0002, 0x009c},
		{0x0000, 0x0000, 0x1041, 0x0002, 0x00a4},
		{0x0000, 0x0000, 0x1001, 0x0002, 0x00ac},
		{0xcc00, 0x0000, 0x0000, 0x0000, 0x00c0},
		{0x000c, 0x0003, 0x0000, 0x0000, 0x00c4},
		{0x0300, 0x0002, 0x0000, 0x0000, 0x00c8},
		{0x0c08, 0x0000, 0x0000, 0x0000, 0x00cc},
		{0x0c00, 0x000c, 0x0000, 0x0000, 0x00d0},
		{0x000c, 0x0000, 0x0000, 0x0000, 0x00d4},
		{0x0000, 0x0000, 0x4082, 0x0001, 0x00e0},
		{0x0000, 0x0000, 0xc042, 0x0000, 0x00e4},
		{0x0000, 0x0000, 0x9201, 0x0001, 0x00ec},
		{0x0000, 0x0000, 0xc042, 0x0000, 0x00f0},
		{0x0000, 0x0000, 0xc042, 0x0000, 0x00f4},
		{0x0000, 0x0200, 0x0000, 0x0000, 0x0104},
		{0x0000, 0x0200, 0x0000, 0x0000, 0x0108},
		{0x0000, 0x0040, 0x0000, 0x0000, 0x010c},
		{0x0080, 0x0200, 0x0000, 0x0000, 0x0110},
		{0x0000, 0x0200, 0x0000, 0x0000, 0x0118},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x011c},
		{0x0000, 0x0000, 0x4002, 0x0002, 0x012c},
		{0x0000, 0x0000, 0xc001, 0x0001, 0x0130},
		{0x0000, 0x0000, 0x4002, 0x0002, 0x013c},
		{0x0000, 0x0000, 0xc001, 0x0001, 0x0140},
		{0x2000, 0x0000, 0x0000, 0x0000, 0x014c},
		{0x2000, 0x0000, 0x0000, 0x0000, 0x0150},
		{0x0041, 0x0000, 0x0000, 0x0000, 0x0154},
		{0x0301, 0x0000, 0x0000, 0x0000, 0x0158},
		{0x2000, 0x0000, 0x0000, 0x0000, 0x0160},
		{0x0041, 0x0000, 0x0000, 0x0000, 0x0164},
		{0xe000, 0x0000, 0x0400, 0x0000, 0x016c},
		{0x0000, 0x0000, 0x23c0, 0x0020, 0x016d},
		{0xa000, 0x0000, 0x0400, 0x0000, 0x0170},
		{0x0000, 0x0000, 0x23c0, 0x0020, 0x0171},
		{0x9000, 0x0000, 0x0400, 0x0000, 0x0174},
		{0x0000, 0x0000, 0x0040, 0x0000, 0x0175},
		{0xc000, 0x0000, 0x0400, 0x0000, 0x0178},
		{0x0000, 0x0000, 0x0040, 0x0000, 0x0179},
		{0xcf80, 0x0000, 0x0400, 0x0000, 0x017c},
		{0x0000, 0x0000, 0x23c0, 0x0000, 0x017d},
		{0xe000, 0x0000, 0x0400, 0x0000, 0x0180},
		{0x0000, 0x0000, 0x23c0, 0x0020, 0x0181},
		{0x9000, 0x0000, 0x0400, 0x0000, 0x0184},
		{0x0000, 0x0000, 0x0040, 0x0000, 0x0185},
		{0xa000, 0x0000, 0x0400, 0x0000, 0x0188},
		{0x0000, 0x0000, 0x0040, 0x0000, 0x0189},
	};

	load_cfg((void*)cin, 0x804d0, 780, 7, 0);
	load_data(din_addr[0], 0x44000, 16384, 0, 7, 0);
	load_data(din_addr[1], 0x0, 16384, 0, 7, 0);
	load_data(din_addr[2], 0x50000, 16384, 0, 7, 0);
	load_data(din_addr[3], 0x8000, 16384, 0, 7, 0);
	load_data(din_addr[4], 0x64000, 16384, 0, 7, 0);
	load_data(din_addr[5], 0x20000, 16384, 0, 7, 0);
	load_data(din_addr[6], 0x68000, 16384, 0, 7, 0);
	load_data(din_addr[7], 0x28000, 16384, 0, 7, 0);
	config(0x4d, 78, 7, 0);
	execute(0xffff, 7, 0);
	store(dout_addr[0], 0x30000, 16384, 7, 0);
	store(dout_addr[1], 0x10000, 16384, 7, 0);
	store(dout_addr[2], 0x78000, 16384, 7, 0);
	store(dout_addr[3], 0x48000, 16384, 7, 0);
	store(dout_addr[4], 0x18000, 16384, 7, 0);
	store(dout_addr[5], 0x73e00, 16384, 7, 0);
	store(dout_addr[6], 0x38000, 16384, 7, 0);
	store(dout_addr[7], 0x58000, 16384, 7, 0);
}


void gemm_cgra_execute(void** din_addr, void** dout_addr)
{
	static unsigned short cin[47][5] __attribute__((aligned(16))) = {
		{0x3040, 0x0080, 0x1004, 0x0710, 0x0008},
		{0x8202, 0x40e1, 0x0040, 0x0000, 0x0009},
		{0x1001, 0x0002, 0x4004, 0x07fc, 0x000c},
		{0x0802, 0x4000, 0x0040, 0x0000, 0x000d},
		{0x5000, 0x0000, 0x1004, 0x0000, 0x0010},
		{0x0202, 0x4000, 0x24c0, 0x0000, 0x0011},
		{0x3003, 0x0002, 0x4004, 0x07fc, 0x0018},
		{0x0802, 0x4000, 0x0040, 0x0000, 0x0019},
		{0x1000, 0x0002, 0x4004, 0x07fc, 0x001c},
		{0x0802, 0x4000, 0x0040, 0x0000, 0x001d},
		{0x0400, 0x0000, 0x0000, 0x0000, 0x0030},
		{0x0030, 0x0000, 0x0000, 0x0000, 0x0034},
		{0x0000, 0x0030, 0x0000, 0x0000, 0x003c},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0040},
		{0x0000, 0x0000, 0x9003, 0x0000, 0x0054},
		{0x0000, 0x0008, 0x0000, 0x0000, 0x007c},
		{0x0000, 0x0600, 0x0000, 0x0000, 0x0084},
		{0x0000, 0x0600, 0x0000, 0x0000, 0x0088},
		{0x0000, 0x0000, 0x4011, 0x0000, 0x009c},
		{0x0000, 0x0004, 0x0408, 0x0000, 0x009d},
		{0x0001, 0x0000, 0x0000, 0x0000, 0x009e},
		{0x0000, 0x0000, 0x9081, 0x0001, 0x00a0},
		{0x04c0, 0x0000, 0x0000, 0x0000, 0x00c4},
		{0x8000, 0x0000, 0x0000, 0x0000, 0x00cc},
		{0x8000, 0x0000, 0x0000, 0x0000, 0x00d0},
		{0x0000, 0x0000, 0xc081, 0x0000, 0x00e8},
		{0x0000, 0x0000, 0x3003, 0x0001, 0x00ec},
		{0x0000, 0x0000, 0x4043, 0x0001, 0x00f0},
		{0x0000, 0x0100, 0x0000, 0x0000, 0x010c},
		{0xc020, 0x0000, 0x0000, 0x0000, 0x0110},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0114},
		{0x0003, 0x0000, 0x0000, 0x0000, 0x0118},
		{0x0000, 0x0000, 0x2001, 0x0001, 0x0130},
		{0x0000, 0x0000, 0x3203, 0x0002, 0x0134},
		{0x0000, 0x0010, 0x0000, 0x0000, 0x0150},
		{0x0000, 0x0024, 0x0000, 0x0000, 0x0154},
		{0x0020, 0x0000, 0x0000, 0x0000, 0x0158},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x015c},
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0160},
		{0x5080, 0x0080, 0x1004, 0x0710, 0x0170},
		{0x8202, 0x40e1, 0x0040, 0x0000, 0x0171},
		{0x0000, 0x0080, 0x1004, 0x0710, 0x0174},
		{0x8202, 0x40e1, 0x0040, 0x0000, 0x0175},
		{0x0002, 0x0002, 0x4004, 0x07fc, 0x0180},
		{0x0802, 0x4000, 0x0040, 0x0000, 0x0181},
		{0x30c0, 0x0080, 0x1004, 0x0710, 0x0184},
		{0x8202, 0x40e1, 0x0040, 0x0000, 0x0185},
	};

	load_cfg((void*)cin, 0x80000, 470, 8, 0);
	load_data(din_addr[0], 0x24000, 16384, 1, 8, 0);
	load_data(din_addr[1], 0x4000, 16384, 1, 8, 0);
	load_data(din_addr[2], 0x60000, 16384, 1, 8, 0);
	load_data(din_addr[3], 0x2c000, 16384, 0, 8, 0);
	load_data(din_addr[4], 0x40000, 16384, 1, 8, 0);
	load_data(din_addr[5], 0xc000, 16384, 1, 8, 0);
	load_data(din_addr[6], 0x54000, 16384, 1, 8, 0);
	load_data(din_addr[7], 0x6c000, 16384, 0, 8, 0);
	config(0x0, 47, 8, 0);
	execute(0x666e, 8, 0);
	store(dout_addr[0], 0x14000, 16384, 8, 0);
}



///* Array initialization. */
//void init_array()
//{
//int i,j;
//for (i=0;i<array_add_SIZE; i++){
//      gemver_A[i] = i * 2 + 5;
//      conv2d_2x2_B[i] = i * 3;
//    }
//
//}
//
//void result_check()
//{
//  int i, j;
//
//  for (i = 0; i < array_add_SIZE; i++)
//  {
//    if (conv2d_2x2_C[i] != D[i]) printf("There is an error in location (%d)[%d, %d]\n", i, conv2d_2x2_C[i], D[i]);
//  }
//}


int main(int argc, char** argv)
{
  long long unsigned start;
  long long unsigned end;
  volatile int result;
//  init_array();
  printf("Initialization finished!\n");

//  start = rdcycle();
//  /* Run kernels. */
////  ellpack();
//  fir();
//  stencil3d();
//  gesummv();
//  conv2d_3x3();
//  kernel_mvt();
//  pedometer();
//  stencil2d();
//  fft4();
//  gemm();
//  end = rdcycle();
//  printf("It takes %d cycles for CPU to finish the task.\n", end - start);

  start = rdcycle();

//  void* ellpack_cgra_din_addr[4] = {cols, nzval, out, vec};
//  void* ellpack_cgra_dout_addr[1] = {out};
//  ellpack_cgra_execute(ellpack_cgra_din_addr, ellpack_cgra_dout_addr);
//  result = fence(1);

  void* fir_cgra_din_addr[2] = {fir_coefficients, fir_input};
  void* fir_cgra_dout_addr[1] = {fir_output};
  fir_cgra_execute(fir_cgra_din_addr, fir_cgra_dout_addr);
//  result = fence(1);

  void* stencil3d_cgra_din_addr[9] = {stencil3d_C, stencil3d_C, (void*)stencil3d_orig+64, (void*)stencil3d_orig+64,
        (void*)stencil3d_orig+64, (void*)stencil3d_orig+64, (void*)stencil3d_orig+64, (void*)stencil3d_orig+64, (void*)stencil3d_orig+64};
  void* stencil3d_cgra_dout_addr[1] = {(void*)stencil3d_sol+1088};
  stencil3d_cgra_execute(stencil3d_cgra_din_addr, stencil3d_cgra_dout_addr);
//  result = fence(1);

  void* gesummv_cgra_din_addr[3] = {gesummv_A, gesummv_B, gesummv_x};
  void* gesummv_cgra_dout_addr[1] = {gesummv_y};
  gesummv_cgra_execute(gesummv_cgra_din_addr, gesummv_cgra_dout_addr);
//  result = fence(1);

  void* conv2d_3x3_cgra_din_addr[9] = {conv2d_3x3_A, conv2d_3x3_A, conv2d_3x3_A, conv2d_3x3_A, conv2d_3x3_A, conv2d_3x3_A, conv2d_3x3_A, conv2d_3x3_A, conv2d_3x3_A};
  void* conv2d_3x3_cgra_dout_addr[1] = {(void*)conv2d_3x3_B+256};
  conv2d_3x3_cgra_execute(conv2d_3x3_cgra_din_addr, conv2d_3x3_cgra_dout_addr);
//  result = fence(1);

  void* mvt_cgra_din_addr[6] = {mvt_A, mvt_A, mvt_x1, mvt_x2, mvt_y_1, mvt_y_2};
  void* mvt_cgra_dout_addr[2] = {mvt_x1, mvt_x2};
  mvt_cgra_execute(mvt_cgra_din_addr, mvt_cgra_dout_addr);
//  result = fence(1);

  void* pedometer_cgra_din_addr[6] = {acc_avg_x, acc_avg_y, acc_avg_z, acceleration_x, acceleration_y, acceleration_z};
  void* pedometer_cgra_dout_addr[1] = {acc_vector};
  pedometer_cgra_execute(pedometer_cgra_din_addr, pedometer_cgra_dout_addr);
//  result = fence(1);

  void* stencil2d_cgra_din_addr[6] = {stencil2d_filter, stencil2d_filter, stencil2d_filter, stencil2d_orig, stencil2d_orig, stencil2d_orig};
  void* stencil2d_cgra_dout_addr[1] = {stencil2d_sol};
  stencil2d_cgra_execute(stencil2d_cgra_din_addr, stencil2d_cgra_dout_addr);
//  result = fence(1);

  void* fft_cgra_din_addr[8] = {XI0, XI1, XI2, XI3, XR0, XR1, XR2, XR3};
  void* fft_cgra_dout_addr[8] = {YR0, YI0, YR1, YI1, YR2, YI2, YR3, YI3};
  fft_cgra_execute(fft_cgra_din_addr, fft_cgra_dout_addr);
//  result = fence(1);

  void* gemm_cgra_din_addr[8] = {gemm_m1, gemm_m1, gemm_m1, gemm_m1, gemm_m2, gemm_m2, gemm_m2, gemm_m2};
  void* gemm_cgra_dout_addr[1] = {gemm_prod};
  gemm_cgra_execute(gemm_cgra_din_addr, gemm_cgra_dout_addr);
  result = fence(1);

  end = rdcycle();
  printf("It takes %d cycles for CGRA to finish the task(%d).\n", end - start, result);

//  result_check();
  printf("Done!\n");

  return 0;
}